// tslint:disable
/**
 * Famifarm-API
 * Famifarm API specification
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<any>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Identifies a single batch for it's entire life-cycle
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    productId: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CellType {
    SMALL = <any> 'SMALL',
    LARGE = <any> 'LARGE'
}

/**
 * 
 * @export
 * @interface CultivationObservationEventData
 */
export interface CultivationObservationEventData {
    /**
     * Weight in grams
     * @type {number}
     * @memberof CultivationObservationEventData
     */
    weight?: number;
    /**
     * Possible pest observations
     * @type {string}
     * @memberof CultivationObservationEventData
     */
    pests?: string;
    /**
     * Luminance in lumens on the time of observation
     * @type {number}
     * @memberof CultivationObservationEventData
     */
    luminance?: number;
    /**
     * List of ids of cultivation actions done based on observations
     * @type {Array&lt;string&gt;}
     * @memberof CultivationObservationEventData
     */
    performedActionIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The error message
     * @type {string}
     * @memberof ErrorResponse
     */
    message: string;
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    batchId: string;
    /**
     * Id of user who added this entry
     * @type {string}
     * @memberof Event
     */
    userId: string;
    /**
     * Time when the entry was added
     * @type {string}
     * @memberof Event
     */
    time: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    type: Event.TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof Event
     */
    data: any;
}

/**
 * @export
 * @namespace Event
 */
export namespace Event {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PLANTING = <any> 'PLANTING',
        SOWING = <any> 'SOWING',
        PACKING = <any> 'PACKING',
        TABLESPREAD = <any> 'TABLE_SPREAD',
        CULTIVATIONOBSERVATION = <any> 'CULTIVATION_OBSERVATION',
        HARVEST = <any> 'HARVEST',
        WASTEAGE = <any> 'WASTEAGE'
    }
}

/**
 * 
 * @export
 * @interface HarvestEventData
 */
export interface HarvestEventData {
    /**
     * 
     * @type {string}
     * @memberof HarvestEventData
     */
    teamId?: string;
    /**
     * 
     * @type {string}
     * @memberof HarvestEventData
     */
    type?: HarvestEventData.TypeEnum;
    /**
     * Production line id
     * @type {string}
     * @memberof HarvestEventData
     */
    productionLineId?: string;
}

/**
 * @export
 * @namespace HarvestEventData
 */
export namespace HarvestEventData {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        BAGGING = <any> 'BAGGING',
        CUTTING = <any> 'CUTTING',
        BOXING = <any> 'BOXING'
    }
}

/**
 * 
 * @export
 * @interface LocalizedValue
 */
export interface LocalizedValue {
    /**
     * 
     * @type {string}
     * @memberof LocalizedValue
     */
    language: string;
    /**
     * 
     * @type {string}
     * @memberof LocalizedValue
     */
    value: string;
}

/**
 * 
 * @export
 * @interface PackageSize
 */
export interface PackageSize {
    /**
     * 
     * @type {string}
     * @memberof PackageSize
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageSize
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface PackingEventData
 */
export interface PackingEventData {
    /**
     * Amount of packed items
     * @type {number}
     * @memberof PackingEventData
     */
    packedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof PackingEventData
     */
    packageSize?: string;
}

/**
 * 
 * @export
 * @interface PerformedCultivationAction
 */
export interface PerformedCultivationAction {
    /**
     * 
     * @type {string}
     * @memberof PerformedCultivationAction
     */
    id?: string;
    /**
     * 
     * @type {Array&lt;LocalizedValue&gt;}
     * @memberof PerformedCultivationAction
     */
    name?: Array<LocalizedValue>;
}

/**
 * 
 * @export
 * @interface PlantingEventData
 */
export interface PlantingEventData {
    /**
     * Production line id
     * @type {string}
     * @memberof PlantingEventData
     */
    productionLineId?: string;
    /**
     * 
     * @type {number}
     * @memberof PlantingEventData
     */
    gutterNumber?: number;
    /**
     * How many gutter were used during the planting
     * @type {number}
     * @memberof PlantingEventData
     */
    gutterCount?: number;
    /**
     * How many trays were planted
     * @type {number}
     * @memberof PlantingEventData
     */
    trayCount?: number;
    /**
     * How many workers were doing the planting
     * @type {number}
     * @memberof PlantingEventData
     */
    workerCount?: number;
    /**
     * Duration of work in minutes
     * @type {number}
     * @memberof PlantingEventData
     */
    workDuration?: number;
}

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {Array&lt;LocalizedValue&gt;}
     * @memberof Product
     */
    name?: Array<LocalizedValue>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    defaultPackageSize?: string;
}

/**
 * 
 * @export
 * @interface ProductionLine
 */
export interface ProductionLine {
    /**
     * 
     * @type {string}
     * @memberof ProductionLine
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductionLine
     */
    lineNumber?: number;
}

/**
 * 
 * @export
 * @interface Seed
 */
export interface Seed {
    /**
     * 
     * @type {string}
     * @memberof Seed
     */
    id?: string;
    /**
     * 
     * @type {Array&lt;LocalizedValue&gt;}
     * @memberof Seed
     */
    name?: Array<LocalizedValue>;
}

/**
 * 
 * @export
 * @interface SeedBatch
 */
export interface SeedBatch {
    /**
     * 
     * @type {string}
     * @memberof SeedBatch
     */
    id?: string;
    /**
     * Manufacturer's code for the batch
     * @type {string}
     * @memberof SeedBatch
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof SeedBatch
     */
    seedId?: string;
    /**
     * Time when the seed has arrived
     * @type {string}
     * @memberof SeedBatch
     */
    time?: string;
}

/**
 * Entry when a batch has been sowed
 * @export
 * @interface SowingEventData
 */
export interface SowingEventData {
    /**
     * 
     * @type {string}
     * @memberof SowingEventData
     */
    productionLineId: string;
    /**
     * 
     * @type {number}
     * @memberof SowingEventData
     */
    gutterNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof SowingEventData
     */
    seedBatchId?: string;
    /**
     * 
     * @type {CellType}
     * @memberof SowingEventData
     */
    cellType: CellType;
    /**
     * 
     * @type {number}
     * @memberof SowingEventData
     */
    amount: number;
}

/**
 * Event of spreading the young plant trays to nursery tables
 * @export
 * @interface TableSpreadEventData
 */
export interface TableSpreadEventData {
    /**
     * Count of tables used
     * @type {number}
     * @memberof TableSpreadEventData
     */
    tableCount?: number;
    /**
     * Where the batch has been placed
     * @type {string}
     * @memberof TableSpreadEventData
     */
    location?: string;
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    id?: string;
    /**
     * 
     * @type {Array&lt;LocalizedValue&gt;}
     * @memberof Team
     */
    name?: Array<LocalizedValue>;
}

/**
 * Entry of products has been thrown away
 * @export
 * @interface WastageEventData
 */
export interface WastageEventData {
    /**
     * Id of reason a product has been thrown away
     * @type {string}
     * @memberof WastageEventData
     */
    reasonId?: string;
    /**
     * 
     * @type {number}
     * @memberof WastageEventData
     */
    amount?: number;
}

/**
 * Reason why a product has been thrown away
 * @export
 * @interface WastageReason
 */
export interface WastageReason {
    /**
     * 
     * @type {string}
     * @memberof WastageReason
     */
    id?: string;
    /**
     * 
     * @type {Array&lt;LocalizedValue&gt;}
     * @memberof WastageReason
     */
    reason?: Array<LocalizedValue>;
}


/**
 * BatchesApi - fetch parameter creator
 * @export
 */
export const BatchesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new batch
         * @param {Batch} batch Batch to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(batch: Batch, options: any = {}): FetchArgs {
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling createBatch.');
            }
            const path = `/v1/batches`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(batch || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a batch
         * @param {string} batchId BatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId: string, options: any = {}): FetchArgs {
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling deleteBatch.');
            }
            const path = `/v1/batches/{batchId}`
                .replace(`{${"batchId"}}`, String(batchId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a batch
         * @param {string} batchId Batch id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBatch(batchId: string, options: any = {}): FetchArgs {
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling findBatch.');
            }
            const path = `/v1/batches/{batchId}`
                .replace(`{${"batchId"}}`, String(batchId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all batches
         * @param {number} [maxResult] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(maxResult?: number, options: any = {}): FetchArgs {
            const path = `/v1/batches`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (maxResult !== undefined) {
                queryParameter['maxResult'] = maxResult;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a batch
         * @param {string} batchId Batch id
         * @param {Batch} batch Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId: string, batch: Batch, options: any = {}): FetchArgs {
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling updateBatch.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling updateBatch.');
            }
            const path = `/v1/batches/{batchId}`
                .replace(`{${"batchId"}}`, String(batchId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(batch || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new batch
         * @param {Batch} batch Batch to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(batch: Batch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Batch> {
            const fetchArgs = BatchesApiFetchParamCreator(configuration).createBatch(batch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a batch
         * @param {string} batchId BatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = BatchesApiFetchParamCreator(configuration).deleteBatch(batchId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a batch
         * @param {string} batchId Batch id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBatch(batchId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Batch> {
            const fetchArgs = BatchesApiFetchParamCreator(configuration).findBatch(batchId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all batches
         * @param {number} [maxResult] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(maxResult?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Batch>> {
            const fetchArgs = BatchesApiFetchParamCreator(configuration).listBatches(maxResult, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a batch
         * @param {string} batchId Batch id
         * @param {Batch} batch Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId: string, batch: Batch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Batch> {
            const fetchArgs = BatchesApiFetchParamCreator(configuration).updateBatch(batchId, batch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new batch
         * @param {Batch} batch Batch to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(batch: Batch, options?: any) {
            return BatchesApiFp(configuration).createBatch(batch, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a batch
         * @param {string} batchId BatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId: string, options?: any) {
            return BatchesApiFp(configuration).deleteBatch(batchId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a batch
         * @param {string} batchId Batch id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBatch(batchId: string, options?: any) {
            return BatchesApiFp(configuration).findBatch(batchId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all batches
         * @param {number} [maxResult] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(maxResult?: number, options?: any) {
            return BatchesApiFp(configuration).listBatches(maxResult, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a batch
         * @param {string} batchId Batch id
         * @param {Batch} batch Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId: string, batch: Batch, options?: any) {
            return BatchesApiFp(configuration).updateBatch(batchId, batch, options)(fetch, basePath);
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * 
     * @summary Create new batch
     * @param {} batch Batch to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatch(batch: Batch, options?: any) {
        return BatchesApiFp(this.configuration).createBatch(batch, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a batch
     * @param {} batchId BatchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public deleteBatch(batchId: string, options?: any) {
        return BatchesApiFp(this.configuration).deleteBatch(batchId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a batch
     * @param {} batchId Batch id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public findBatch(batchId: string, options?: any) {
        return BatchesApiFp(this.configuration).findBatch(batchId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all batches
     * @param {} [maxResult] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatches(maxResult?: number, options?: any) {
        return BatchesApiFp(this.configuration).listBatches(maxResult, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a batch
     * @param {} batchId Batch id
     * @param {} batch Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public updateBatch(batchId: string, batch: Batch, options?: any) {
        return BatchesApiFp(this.configuration).updateBatch(batchId, batch, options)(this.fetch, this.basePath);
    }

}

/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new event
         * @param {Event} event Event to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: Event, options: any = {}): FetchArgs {
            // verify required parameter 'event' is not null or undefined
            if (event === null || event === undefined) {
                throw new RequiredError('event','Required parameter event was null or undefined when calling createEvent.');
            }
            const path = `/v1/events`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(event || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling deleteEvent.');
            }
            const path = `/v1/events/{eventId}`
                .replace(`{${"eventId"}}`, String(eventId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find an event
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEvent(eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling findEvent.');
            }
            const path = `/v1/events/{eventId}`
                .replace(`{${"eventId"}}`, String(eventId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all events
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/events`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates an event
         * @param {string} eventId Event id
         * @param {Event} event Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, event: Event, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling updateEvent.');
            }
            // verify required parameter 'event' is not null or undefined
            if (event === null || event === undefined) {
                throw new RequiredError('event','Required parameter event was null or undefined when calling updateEvent.');
            }
            const path = `/v1/events/{eventId}`
                .replace(`{${"eventId"}}`, String(eventId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(event || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new event
         * @param {Event} event Event to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: Event, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const fetchArgs = EventsApiFetchParamCreator(configuration).createEvent(event, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes an event
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = EventsApiFetchParamCreator(configuration).deleteEvent(eventId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find an event
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEvent(eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const fetchArgs = EventsApiFetchParamCreator(configuration).findEvent(eventId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all events
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const fetchArgs = EventsApiFetchParamCreator(configuration).listEvents(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an event
         * @param {string} eventId Event id
         * @param {Event} event Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, event: Event, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const fetchArgs = EventsApiFetchParamCreator(configuration).updateEvent(eventId, event, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new event
         * @param {Event} event Event to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: Event, options?: any) {
            return EventsApiFp(configuration).createEvent(event, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes an event
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options?: any) {
            return EventsApiFp(configuration).deleteEvent(eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find an event
         * @param {string} eventId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEvent(eventId: string, options?: any) {
            return EventsApiFp(configuration).findEvent(eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all events
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(firstResult?: number, maxResults?: number, options?: any) {
            return EventsApiFp(configuration).listEvents(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an event
         * @param {string} eventId Event id
         * @param {Event} event Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, event: Event, options?: any) {
            return EventsApiFp(configuration).updateEvent(eventId, event, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Create new event
     * @param {} event Event to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(event: Event, options?: any) {
        return EventsApiFp(this.configuration).createEvent(event, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes an event
     * @param {} eventId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(eventId: string, options?: any) {
        return EventsApiFp(this.configuration).deleteEvent(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find an event
     * @param {} eventId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public findEvent(eventId: string, options?: any) {
        return EventsApiFp(this.configuration).findEvent(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all events
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEvents(firstResult?: number, maxResults?: number, options?: any) {
        return EventsApiFp(this.configuration).listEvents(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an event
     * @param {} eventId Event id
     * @param {} event Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(eventId: string, event: Event, options?: any) {
        return EventsApiFp(this.configuration).updateEvent(eventId, event, options)(this.fetch, this.basePath);
    }

}

/**
 * PackageSizesApi - fetch parameter creator
 * @export
 */
export const PackageSizesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new package size
         * @param {PackageSize} packageSize Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageSize(packageSize: PackageSize, options: any = {}): FetchArgs {
            // verify required parameter 'packageSize' is not null or undefined
            if (packageSize === null || packageSize === undefined) {
                throw new RequiredError('packageSize','Required parameter packageSize was null or undefined when calling createPackageSize.');
            }
            const path = `/v1/packageSizes`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(packageSize || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a package size
         * @param {string} packageSizeId PackageSizeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageSize(packageSizeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'packageSizeId' is not null or undefined
            if (packageSizeId === null || packageSizeId === undefined) {
                throw new RequiredError('packageSizeId','Required parameter packageSizeId was null or undefined when calling deletePackageSize.');
            }
            const path = `/v1/packageSizes/{packageSizeId}`
                .replace(`{${"packageSizeId"}}`, String(packageSizeId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a package size
         * @param {string} packageSizeId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPackageSize(packageSizeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'packageSizeId' is not null or undefined
            if (packageSizeId === null || packageSizeId === undefined) {
                throw new RequiredError('packageSizeId','Required parameter packageSizeId was null or undefined when calling findPackageSize.');
            }
            const path = `/v1/packageSizes/{packageSizeId}`
                .replace(`{${"packageSizeId"}}`, String(packageSizeId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all package sizes
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageSizes(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/packageSizes`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a package size
         * @param {string} packageSizeId Wastage reason id
         * @param {PackageSize} packageSize Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageSize(packageSizeId: string, packageSize: PackageSize, options: any = {}): FetchArgs {
            // verify required parameter 'packageSizeId' is not null or undefined
            if (packageSizeId === null || packageSizeId === undefined) {
                throw new RequiredError('packageSizeId','Required parameter packageSizeId was null or undefined when calling updatePackageSize.');
            }
            // verify required parameter 'packageSize' is not null or undefined
            if (packageSize === null || packageSize === undefined) {
                throw new RequiredError('packageSize','Required parameter packageSize was null or undefined when calling updatePackageSize.');
            }
            const path = `/v1/packageSizes/{packageSizeId}`
                .replace(`{${"packageSizeId"}}`, String(packageSizeId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(packageSize || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * PackageSizesApi - functional programming interface
 * @export
 */
export const PackageSizesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new package size
         * @param {PackageSize} packageSize Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageSize(packageSize: PackageSize, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PackageSize> {
            const fetchArgs = PackageSizesApiFetchParamCreator(configuration).createPackageSize(packageSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a package size
         * @param {string} packageSizeId PackageSizeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageSize(packageSizeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = PackageSizesApiFetchParamCreator(configuration).deletePackageSize(packageSizeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a package size
         * @param {string} packageSizeId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPackageSize(packageSizeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PackageSize> {
            const fetchArgs = PackageSizesApiFetchParamCreator(configuration).findPackageSize(packageSizeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all package sizes
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageSizes(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PackageSize>> {
            const fetchArgs = PackageSizesApiFetchParamCreator(configuration).listPackageSizes(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a package size
         * @param {string} packageSizeId Wastage reason id
         * @param {PackageSize} packageSize Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageSize(packageSizeId: string, packageSize: PackageSize, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PackageSize> {
            const fetchArgs = PackageSizesApiFetchParamCreator(configuration).updatePackageSize(packageSizeId, packageSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PackageSizesApi - factory interface
 * @export
 */
export const PackageSizesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new package size
         * @param {PackageSize} packageSize Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageSize(packageSize: PackageSize, options?: any) {
            return PackageSizesApiFp(configuration).createPackageSize(packageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a package size
         * @param {string} packageSizeId PackageSizeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageSize(packageSizeId: string, options?: any) {
            return PackageSizesApiFp(configuration).deletePackageSize(packageSizeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a package size
         * @param {string} packageSizeId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPackageSize(packageSizeId: string, options?: any) {
            return PackageSizesApiFp(configuration).findPackageSize(packageSizeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all package sizes
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageSizes(firstResult?: number, maxResults?: number, options?: any) {
            return PackageSizesApiFp(configuration).listPackageSizes(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a package size
         * @param {string} packageSizeId Wastage reason id
         * @param {PackageSize} packageSize Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageSize(packageSizeId: string, packageSize: PackageSize, options?: any) {
            return PackageSizesApiFp(configuration).updatePackageSize(packageSizeId, packageSize, options)(fetch, basePath);
        },
    };
};

/**
 * PackageSizesApi - object-oriented interface
 * @export
 * @class PackageSizesApi
 * @extends {BaseAPI}
 */
export class PackageSizesApi extends BaseAPI {
    /**
     * 
     * @summary Create new package size
     * @param {} packageSize Wastage reason to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageSizesApi
     */
    public createPackageSize(packageSize: PackageSize, options?: any) {
        return PackageSizesApiFp(this.configuration).createPackageSize(packageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a package size
     * @param {} packageSizeId PackageSizeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageSizesApi
     */
    public deletePackageSize(packageSizeId: string, options?: any) {
        return PackageSizesApiFp(this.configuration).deletePackageSize(packageSizeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a package size
     * @param {} packageSizeId Wastage reason id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageSizesApi
     */
    public findPackageSize(packageSizeId: string, options?: any) {
        return PackageSizesApiFp(this.configuration).findPackageSize(packageSizeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all package sizes
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageSizesApi
     */
    public listPackageSizes(firstResult?: number, maxResults?: number, options?: any) {
        return PackageSizesApiFp(this.configuration).listPackageSizes(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a package size
     * @param {} packageSizeId Wastage reason id
     * @param {} packageSize Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageSizesApi
     */
    public updatePackageSize(packageSizeId: string, packageSize: PackageSize, options?: any) {
        return PackageSizesApiFp(this.configuration).updatePackageSize(packageSizeId, packageSize, options)(this.fetch, this.basePath);
    }

}

/**
 * PerformedCultivationActionsApi - fetch parameter creator
 * @export
 */
export const PerformedCultivationActionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new performed cultivation action
         * @param {PerformedCultivationAction} performedCultivationAction Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerformedCultivationAction(performedCultivationAction: PerformedCultivationAction, options: any = {}): FetchArgs {
            // verify required parameter 'performedCultivationAction' is not null or undefined
            if (performedCultivationAction === null || performedCultivationAction === undefined) {
                throw new RequiredError('performedCultivationAction','Required parameter performedCultivationAction was null or undefined when calling createPerformedCultivationAction.');
            }
            const path = `/v1/performedCultivationActions`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(performedCultivationAction || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a performed cultivation action
         * @param {string} performedCultivationActionId PerformedCultivationActionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerformedCultivationAction(performedCultivationActionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'performedCultivationActionId' is not null or undefined
            if (performedCultivationActionId === null || performedCultivationActionId === undefined) {
                throw new RequiredError('performedCultivationActionId','Required parameter performedCultivationActionId was null or undefined when calling deletePerformedCultivationAction.');
            }
            const path = `/v1/performedCultivationActions/{performedCultivationActionId}`
                .replace(`{${"performedCultivationActionId"}}`, String(performedCultivationActionId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a performed cultivation action
         * @param {string} performedCultivationActionId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPerformedCultivationAction(performedCultivationActionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'performedCultivationActionId' is not null or undefined
            if (performedCultivationActionId === null || performedCultivationActionId === undefined) {
                throw new RequiredError('performedCultivationActionId','Required parameter performedCultivationActionId was null or undefined when calling findPerformedCultivationAction.');
            }
            const path = `/v1/performedCultivationActions/{performedCultivationActionId}`
                .replace(`{${"performedCultivationActionId"}}`, String(performedCultivationActionId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all performed cultivation actions
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPerformedCultivationActions(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/performedCultivationActions`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a performed cultivation action
         * @param {string} performedCultivationActionId Wastage reason id
         * @param {PerformedCultivationAction} performedCultivationAction Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerformedCultivationAction(performedCultivationActionId: string, performedCultivationAction: PerformedCultivationAction, options: any = {}): FetchArgs {
            // verify required parameter 'performedCultivationActionId' is not null or undefined
            if (performedCultivationActionId === null || performedCultivationActionId === undefined) {
                throw new RequiredError('performedCultivationActionId','Required parameter performedCultivationActionId was null or undefined when calling updatePerformedCultivationAction.');
            }
            // verify required parameter 'performedCultivationAction' is not null or undefined
            if (performedCultivationAction === null || performedCultivationAction === undefined) {
                throw new RequiredError('performedCultivationAction','Required parameter performedCultivationAction was null or undefined when calling updatePerformedCultivationAction.');
            }
            const path = `/v1/performedCultivationActions/{performedCultivationActionId}`
                .replace(`{${"performedCultivationActionId"}}`, String(performedCultivationActionId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(performedCultivationAction || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * PerformedCultivationActionsApi - functional programming interface
 * @export
 */
export const PerformedCultivationActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new performed cultivation action
         * @param {PerformedCultivationAction} performedCultivationAction Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerformedCultivationAction(performedCultivationAction: PerformedCultivationAction, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerformedCultivationAction> {
            const fetchArgs = PerformedCultivationActionsApiFetchParamCreator(configuration).createPerformedCultivationAction(performedCultivationAction, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a performed cultivation action
         * @param {string} performedCultivationActionId PerformedCultivationActionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerformedCultivationAction(performedCultivationActionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = PerformedCultivationActionsApiFetchParamCreator(configuration).deletePerformedCultivationAction(performedCultivationActionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a performed cultivation action
         * @param {string} performedCultivationActionId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPerformedCultivationAction(performedCultivationActionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerformedCultivationAction> {
            const fetchArgs = PerformedCultivationActionsApiFetchParamCreator(configuration).findPerformedCultivationAction(performedCultivationActionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all performed cultivation actions
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPerformedCultivationActions(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PerformedCultivationAction>> {
            const fetchArgs = PerformedCultivationActionsApiFetchParamCreator(configuration).listPerformedCultivationActions(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a performed cultivation action
         * @param {string} performedCultivationActionId Wastage reason id
         * @param {PerformedCultivationAction} performedCultivationAction Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerformedCultivationAction(performedCultivationActionId: string, performedCultivationAction: PerformedCultivationAction, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerformedCultivationAction> {
            const fetchArgs = PerformedCultivationActionsApiFetchParamCreator(configuration).updatePerformedCultivationAction(performedCultivationActionId, performedCultivationAction, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PerformedCultivationActionsApi - factory interface
 * @export
 */
export const PerformedCultivationActionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new performed cultivation action
         * @param {PerformedCultivationAction} performedCultivationAction Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerformedCultivationAction(performedCultivationAction: PerformedCultivationAction, options?: any) {
            return PerformedCultivationActionsApiFp(configuration).createPerformedCultivationAction(performedCultivationAction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a performed cultivation action
         * @param {string} performedCultivationActionId PerformedCultivationActionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerformedCultivationAction(performedCultivationActionId: string, options?: any) {
            return PerformedCultivationActionsApiFp(configuration).deletePerformedCultivationAction(performedCultivationActionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a performed cultivation action
         * @param {string} performedCultivationActionId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPerformedCultivationAction(performedCultivationActionId: string, options?: any) {
            return PerformedCultivationActionsApiFp(configuration).findPerformedCultivationAction(performedCultivationActionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all performed cultivation actions
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPerformedCultivationActions(firstResult?: number, maxResults?: number, options?: any) {
            return PerformedCultivationActionsApiFp(configuration).listPerformedCultivationActions(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a performed cultivation action
         * @param {string} performedCultivationActionId Wastage reason id
         * @param {PerformedCultivationAction} performedCultivationAction Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerformedCultivationAction(performedCultivationActionId: string, performedCultivationAction: PerformedCultivationAction, options?: any) {
            return PerformedCultivationActionsApiFp(configuration).updatePerformedCultivationAction(performedCultivationActionId, performedCultivationAction, options)(fetch, basePath);
        },
    };
};

/**
 * PerformedCultivationActionsApi - object-oriented interface
 * @export
 * @class PerformedCultivationActionsApi
 * @extends {BaseAPI}
 */
export class PerformedCultivationActionsApi extends BaseAPI {
    /**
     * 
     * @summary Create new performed cultivation action
     * @param {} performedCultivationAction Wastage reason to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformedCultivationActionsApi
     */
    public createPerformedCultivationAction(performedCultivationAction: PerformedCultivationAction, options?: any) {
        return PerformedCultivationActionsApiFp(this.configuration).createPerformedCultivationAction(performedCultivationAction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a performed cultivation action
     * @param {} performedCultivationActionId PerformedCultivationActionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformedCultivationActionsApi
     */
    public deletePerformedCultivationAction(performedCultivationActionId: string, options?: any) {
        return PerformedCultivationActionsApiFp(this.configuration).deletePerformedCultivationAction(performedCultivationActionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a performed cultivation action
     * @param {} performedCultivationActionId Wastage reason id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformedCultivationActionsApi
     */
    public findPerformedCultivationAction(performedCultivationActionId: string, options?: any) {
        return PerformedCultivationActionsApiFp(this.configuration).findPerformedCultivationAction(performedCultivationActionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all performed cultivation actions
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformedCultivationActionsApi
     */
    public listPerformedCultivationActions(firstResult?: number, maxResults?: number, options?: any) {
        return PerformedCultivationActionsApiFp(this.configuration).listPerformedCultivationActions(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a performed cultivation action
     * @param {} performedCultivationActionId Wastage reason id
     * @param {} performedCultivationAction Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformedCultivationActionsApi
     */
    public updatePerformedCultivationAction(performedCultivationActionId: string, performedCultivationAction: PerformedCultivationAction, options?: any) {
        return PerformedCultivationActionsApiFp(this.configuration).updatePerformedCultivationAction(performedCultivationActionId, performedCultivationAction, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductionLinesApi - fetch parameter creator
 * @export
 */
export const ProductionLinesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new production line
         * @param {ProductionLine} productionLine Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductionLine(productionLine: ProductionLine, options: any = {}): FetchArgs {
            // verify required parameter 'productionLine' is not null or undefined
            if (productionLine === null || productionLine === undefined) {
                throw new RequiredError('productionLine','Required parameter productionLine was null or undefined when calling createProductionLine.');
            }
            const path = `/v1/productionLines`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(productionLine || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a production line
         * @param {string} productionLineId ProductionLineId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductionLine(productionLineId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productionLineId' is not null or undefined
            if (productionLineId === null || productionLineId === undefined) {
                throw new RequiredError('productionLineId','Required parameter productionLineId was null or undefined when calling deleteProductionLine.');
            }
            const path = `/v1/productionLines/{productionLineId}`
                .replace(`{${"productionLineId"}}`, String(productionLineId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a production line
         * @param {string} productionLineId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductionLine(productionLineId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productionLineId' is not null or undefined
            if (productionLineId === null || productionLineId === undefined) {
                throw new RequiredError('productionLineId','Required parameter productionLineId was null or undefined when calling findProductionLine.');
            }
            const path = `/v1/productionLines/{productionLineId}`
                .replace(`{${"productionLineId"}}`, String(productionLineId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all production lines
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductionLines(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/productionLines`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a production line
         * @param {string} productionLineId Wastage reason id
         * @param {ProductionLine} productionLine Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductionLine(productionLineId: string, productionLine: ProductionLine, options: any = {}): FetchArgs {
            // verify required parameter 'productionLineId' is not null or undefined
            if (productionLineId === null || productionLineId === undefined) {
                throw new RequiredError('productionLineId','Required parameter productionLineId was null or undefined when calling updateProductionLine.');
            }
            // verify required parameter 'productionLine' is not null or undefined
            if (productionLine === null || productionLine === undefined) {
                throw new RequiredError('productionLine','Required parameter productionLine was null or undefined when calling updateProductionLine.');
            }
            const path = `/v1/productionLines/{productionLineId}`
                .replace(`{${"productionLineId"}}`, String(productionLineId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(productionLine || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * ProductionLinesApi - functional programming interface
 * @export
 */
export const ProductionLinesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new production line
         * @param {ProductionLine} productionLine Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductionLine(productionLine: ProductionLine, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductionLine> {
            const fetchArgs = ProductionLinesApiFetchParamCreator(configuration).createProductionLine(productionLine, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a production line
         * @param {string} productionLineId ProductionLineId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductionLine(productionLineId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = ProductionLinesApiFetchParamCreator(configuration).deleteProductionLine(productionLineId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a production line
         * @param {string} productionLineId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductionLine(productionLineId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductionLine> {
            const fetchArgs = ProductionLinesApiFetchParamCreator(configuration).findProductionLine(productionLineId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all production lines
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductionLines(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProductionLine>> {
            const fetchArgs = ProductionLinesApiFetchParamCreator(configuration).listProductionLines(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a production line
         * @param {string} productionLineId Wastage reason id
         * @param {ProductionLine} productionLine Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductionLine(productionLineId: string, productionLine: ProductionLine, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductionLine> {
            const fetchArgs = ProductionLinesApiFetchParamCreator(configuration).updateProductionLine(productionLineId, productionLine, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductionLinesApi - factory interface
 * @export
 */
export const ProductionLinesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new production line
         * @param {ProductionLine} productionLine Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductionLine(productionLine: ProductionLine, options?: any) {
            return ProductionLinesApiFp(configuration).createProductionLine(productionLine, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a production line
         * @param {string} productionLineId ProductionLineId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductionLine(productionLineId: string, options?: any) {
            return ProductionLinesApiFp(configuration).deleteProductionLine(productionLineId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a production line
         * @param {string} productionLineId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductionLine(productionLineId: string, options?: any) {
            return ProductionLinesApiFp(configuration).findProductionLine(productionLineId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all production lines
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductionLines(firstResult?: number, maxResults?: number, options?: any) {
            return ProductionLinesApiFp(configuration).listProductionLines(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a production line
         * @param {string} productionLineId Wastage reason id
         * @param {ProductionLine} productionLine Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductionLine(productionLineId: string, productionLine: ProductionLine, options?: any) {
            return ProductionLinesApiFp(configuration).updateProductionLine(productionLineId, productionLine, options)(fetch, basePath);
        },
    };
};

/**
 * ProductionLinesApi - object-oriented interface
 * @export
 * @class ProductionLinesApi
 * @extends {BaseAPI}
 */
export class ProductionLinesApi extends BaseAPI {
    /**
     * 
     * @summary Create new production line
     * @param {} productionLine Wastage reason to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductionLinesApi
     */
    public createProductionLine(productionLine: ProductionLine, options?: any) {
        return ProductionLinesApiFp(this.configuration).createProductionLine(productionLine, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a production line
     * @param {} productionLineId ProductionLineId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductionLinesApi
     */
    public deleteProductionLine(productionLineId: string, options?: any) {
        return ProductionLinesApiFp(this.configuration).deleteProductionLine(productionLineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a production line
     * @param {} productionLineId Wastage reason id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductionLinesApi
     */
    public findProductionLine(productionLineId: string, options?: any) {
        return ProductionLinesApiFp(this.configuration).findProductionLine(productionLineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all production lines
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductionLinesApi
     */
    public listProductionLines(firstResult?: number, maxResults?: number, options?: any) {
        return ProductionLinesApiFp(this.configuration).listProductionLines(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a production line
     * @param {} productionLineId Wastage reason id
     * @param {} productionLine Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductionLinesApi
     */
    public updateProductionLine(productionLineId: string, productionLine: ProductionLine, options?: any) {
        return ProductionLinesApiFp(this.configuration).updateProductionLine(productionLineId, productionLine, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductsApi - fetch parameter creator
 * @export
 */
export const ProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new product
         * @param {Product} product Product to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(product: Product, options: any = {}): FetchArgs {
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling createProduct.');
            }
            const path = `/v1/products`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(product || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a product
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProduct.');
            }
            const path = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, String(productId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a product
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling findProduct.');
            }
            const path = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, String(productId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all products
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/products`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a product
         * @param {string} productId Product id
         * @param {Product} product Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, product: Product, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProduct.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling updateProduct.');
            }
            const path = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, String(productId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(product || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new product
         * @param {Product} product Product to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(product: Product, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).createProduct(product, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a product
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).deleteProduct(productId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a product
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).findProduct(productId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all products
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Product>> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).listProducts(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a product
         * @param {string} productId Product id
         * @param {Product} product Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, product: Product, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).updateProduct(productId, product, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new product
         * @param {Product} product Product to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(product: Product, options?: any) {
            return ProductsApiFp(configuration).createProduct(product, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a product
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: string, options?: any) {
            return ProductsApiFp(configuration).deleteProduct(productId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a product
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(productId: string, options?: any) {
            return ProductsApiFp(configuration).findProduct(productId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all products
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(firstResult?: number, maxResults?: number, options?: any) {
            return ProductsApiFp(configuration).listProducts(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a product
         * @param {string} productId Product id
         * @param {Product} product Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, product: Product, options?: any) {
            return ProductsApiFp(configuration).updateProduct(productId, product, options)(fetch, basePath);
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Create new product
     * @param {} product Product to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(product: Product, options?: any) {
        return ProductsApiFp(this.configuration).createProduct(product, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a product
     * @param {} productId Product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProduct(productId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a product
     * @param {} productId Product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public findProduct(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).findProduct(productId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all products
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(firstResult?: number, maxResults?: number, options?: any) {
        return ProductsApiFp(this.configuration).listProducts(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a product
     * @param {} productId Product id
     * @param {} product Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(productId: string, product: Product, options?: any) {
        return ProductsApiFp(this.configuration).updateProduct(productId, product, options)(this.fetch, this.basePath);
    }

}

/**
 * SeedBatchesApi - fetch parameter creator
 * @export
 */
export const SeedBatchesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new seed batch
         * @param {SeedBatch} seedBatch Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeedBatch(seedBatch: SeedBatch, options: any = {}): FetchArgs {
            // verify required parameter 'seedBatch' is not null or undefined
            if (seedBatch === null || seedBatch === undefined) {
                throw new RequiredError('seedBatch','Required parameter seedBatch was null or undefined when calling createSeedBatch.');
            }
            const path = `/v1/seedBatches`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(seedBatch || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a seed batch
         * @param {string} seedBatchId SeedBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeedBatch(seedBatchId: string, options: any = {}): FetchArgs {
            // verify required parameter 'seedBatchId' is not null or undefined
            if (seedBatchId === null || seedBatchId === undefined) {
                throw new RequiredError('seedBatchId','Required parameter seedBatchId was null or undefined when calling deleteSeedBatch.');
            }
            const path = `/v1/seedBatches/{seedBatchId}`
                .replace(`{${"seedBatchId"}}`, String(seedBatchId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a seed batch
         * @param {string} seedBatchId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeedBatch(seedBatchId: string, options: any = {}): FetchArgs {
            // verify required parameter 'seedBatchId' is not null or undefined
            if (seedBatchId === null || seedBatchId === undefined) {
                throw new RequiredError('seedBatchId','Required parameter seedBatchId was null or undefined when calling findSeedBatch.');
            }
            const path = `/v1/seedBatches/{seedBatchId}`
                .replace(`{${"seedBatchId"}}`, String(seedBatchId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all seed batches
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeedBatches(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/seedBatches`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a seed batch
         * @param {string} seedBatchId Wastage reason id
         * @param {SeedBatch} seedBatch Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeedBatch(seedBatchId: string, seedBatch: SeedBatch, options: any = {}): FetchArgs {
            // verify required parameter 'seedBatchId' is not null or undefined
            if (seedBatchId === null || seedBatchId === undefined) {
                throw new RequiredError('seedBatchId','Required parameter seedBatchId was null or undefined when calling updateSeedBatch.');
            }
            // verify required parameter 'seedBatch' is not null or undefined
            if (seedBatch === null || seedBatch === undefined) {
                throw new RequiredError('seedBatch','Required parameter seedBatch was null or undefined when calling updateSeedBatch.');
            }
            const path = `/v1/seedBatches/{seedBatchId}`
                .replace(`{${"seedBatchId"}}`, String(seedBatchId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(seedBatch || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * SeedBatchesApi - functional programming interface
 * @export
 */
export const SeedBatchesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new seed batch
         * @param {SeedBatch} seedBatch Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeedBatch(seedBatch: SeedBatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SeedBatch> {
            const fetchArgs = SeedBatchesApiFetchParamCreator(configuration).createSeedBatch(seedBatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a seed batch
         * @param {string} seedBatchId SeedBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeedBatch(seedBatchId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = SeedBatchesApiFetchParamCreator(configuration).deleteSeedBatch(seedBatchId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a seed batch
         * @param {string} seedBatchId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeedBatch(seedBatchId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SeedBatch> {
            const fetchArgs = SeedBatchesApiFetchParamCreator(configuration).findSeedBatch(seedBatchId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all seed batches
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeedBatches(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SeedBatch>> {
            const fetchArgs = SeedBatchesApiFetchParamCreator(configuration).listSeedBatches(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a seed batch
         * @param {string} seedBatchId Wastage reason id
         * @param {SeedBatch} seedBatch Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeedBatch(seedBatchId: string, seedBatch: SeedBatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SeedBatch> {
            const fetchArgs = SeedBatchesApiFetchParamCreator(configuration).updateSeedBatch(seedBatchId, seedBatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SeedBatchesApi - factory interface
 * @export
 */
export const SeedBatchesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new seed batch
         * @param {SeedBatch} seedBatch Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeedBatch(seedBatch: SeedBatch, options?: any) {
            return SeedBatchesApiFp(configuration).createSeedBatch(seedBatch, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a seed batch
         * @param {string} seedBatchId SeedBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeedBatch(seedBatchId: string, options?: any) {
            return SeedBatchesApiFp(configuration).deleteSeedBatch(seedBatchId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a seed batch
         * @param {string} seedBatchId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeedBatch(seedBatchId: string, options?: any) {
            return SeedBatchesApiFp(configuration).findSeedBatch(seedBatchId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all seed batches
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeedBatches(firstResult?: number, maxResults?: number, options?: any) {
            return SeedBatchesApiFp(configuration).listSeedBatches(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a seed batch
         * @param {string} seedBatchId Wastage reason id
         * @param {SeedBatch} seedBatch Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeedBatch(seedBatchId: string, seedBatch: SeedBatch, options?: any) {
            return SeedBatchesApiFp(configuration).updateSeedBatch(seedBatchId, seedBatch, options)(fetch, basePath);
        },
    };
};

/**
 * SeedBatchesApi - object-oriented interface
 * @export
 * @class SeedBatchesApi
 * @extends {BaseAPI}
 */
export class SeedBatchesApi extends BaseAPI {
    /**
     * 
     * @summary Create new seed batch
     * @param {} seedBatch Wastage reason to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedBatchesApi
     */
    public createSeedBatch(seedBatch: SeedBatch, options?: any) {
        return SeedBatchesApiFp(this.configuration).createSeedBatch(seedBatch, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a seed batch
     * @param {} seedBatchId SeedBatchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedBatchesApi
     */
    public deleteSeedBatch(seedBatchId: string, options?: any) {
        return SeedBatchesApiFp(this.configuration).deleteSeedBatch(seedBatchId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a seed batch
     * @param {} seedBatchId Wastage reason id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedBatchesApi
     */
    public findSeedBatch(seedBatchId: string, options?: any) {
        return SeedBatchesApiFp(this.configuration).findSeedBatch(seedBatchId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all seed batches
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedBatchesApi
     */
    public listSeedBatches(firstResult?: number, maxResults?: number, options?: any) {
        return SeedBatchesApiFp(this.configuration).listSeedBatches(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a seed batch
     * @param {} seedBatchId Wastage reason id
     * @param {} seedBatch Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedBatchesApi
     */
    public updateSeedBatch(seedBatchId: string, seedBatch: SeedBatch, options?: any) {
        return SeedBatchesApiFp(this.configuration).updateSeedBatch(seedBatchId, seedBatch, options)(this.fetch, this.basePath);
    }

}

/**
 * SeedsApi - fetch parameter creator
 * @export
 */
export const SeedsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new seed
         * @param {Seed} seed Seed to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeed(seed: Seed, options: any = {}): FetchArgs {
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed','Required parameter seed was null or undefined when calling createSeed.');
            }
            const path = `/v1/seeds`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(seed || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a seed
         * @param {string} seedId Seed id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeed(seedId: string, options: any = {}): FetchArgs {
            // verify required parameter 'seedId' is not null or undefined
            if (seedId === null || seedId === undefined) {
                throw new RequiredError('seedId','Required parameter seedId was null or undefined when calling deleteSeed.');
            }
            const path = `/v1/seeds/{seedId}`
                .replace(`{${"seedId"}}`, String(seedId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a seed
         * @param {string} seedId Seed id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeed(seedId: string, options: any = {}): FetchArgs {
            // verify required parameter 'seedId' is not null or undefined
            if (seedId === null || seedId === undefined) {
                throw new RequiredError('seedId','Required parameter seedId was null or undefined when calling findSeed.');
            }
            const path = `/v1/seeds/{seedId}`
                .replace(`{${"seedId"}}`, String(seedId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all seeds
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeeds(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/seeds`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a seed
         * @param {string} seedId Seed id
         * @param {Seed} seed Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeed(seedId: string, seed: Seed, options: any = {}): FetchArgs {
            // verify required parameter 'seedId' is not null or undefined
            if (seedId === null || seedId === undefined) {
                throw new RequiredError('seedId','Required parameter seedId was null or undefined when calling updateSeed.');
            }
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed','Required parameter seed was null or undefined when calling updateSeed.');
            }
            const path = `/v1/seeds/{seedId}`
                .replace(`{${"seedId"}}`, String(seedId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(seed || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * SeedsApi - functional programming interface
 * @export
 */
export const SeedsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new seed
         * @param {Seed} seed Seed to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeed(seed: Seed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Seed> {
            const fetchArgs = SeedsApiFetchParamCreator(configuration).createSeed(seed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a seed
         * @param {string} seedId Seed id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeed(seedId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = SeedsApiFetchParamCreator(configuration).deleteSeed(seedId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a seed
         * @param {string} seedId Seed id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeed(seedId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Seed> {
            const fetchArgs = SeedsApiFetchParamCreator(configuration).findSeed(seedId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all seeds
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeeds(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Seed>> {
            const fetchArgs = SeedsApiFetchParamCreator(configuration).listSeeds(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a seed
         * @param {string} seedId Seed id
         * @param {Seed} seed Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeed(seedId: string, seed: Seed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Seed> {
            const fetchArgs = SeedsApiFetchParamCreator(configuration).updateSeed(seedId, seed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SeedsApi - factory interface
 * @export
 */
export const SeedsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new seed
         * @param {Seed} seed Seed to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeed(seed: Seed, options?: any) {
            return SeedsApiFp(configuration).createSeed(seed, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a seed
         * @param {string} seedId Seed id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeed(seedId: string, options?: any) {
            return SeedsApiFp(configuration).deleteSeed(seedId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a seed
         * @param {string} seedId Seed id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeed(seedId: string, options?: any) {
            return SeedsApiFp(configuration).findSeed(seedId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all seeds
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeeds(firstResult?: number, maxResults?: number, options?: any) {
            return SeedsApiFp(configuration).listSeeds(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a seed
         * @param {string} seedId Seed id
         * @param {Seed} seed Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeed(seedId: string, seed: Seed, options?: any) {
            return SeedsApiFp(configuration).updateSeed(seedId, seed, options)(fetch, basePath);
        },
    };
};

/**
 * SeedsApi - object-oriented interface
 * @export
 * @class SeedsApi
 * @extends {BaseAPI}
 */
export class SeedsApi extends BaseAPI {
    /**
     * 
     * @summary Create new seed
     * @param {} seed Seed to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedsApi
     */
    public createSeed(seed: Seed, options?: any) {
        return SeedsApiFp(this.configuration).createSeed(seed, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a seed
     * @param {} seedId Seed id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedsApi
     */
    public deleteSeed(seedId: string, options?: any) {
        return SeedsApiFp(this.configuration).deleteSeed(seedId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a seed
     * @param {} seedId Seed id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedsApi
     */
    public findSeed(seedId: string, options?: any) {
        return SeedsApiFp(this.configuration).findSeed(seedId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all seeds
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedsApi
     */
    public listSeeds(firstResult?: number, maxResults?: number, options?: any) {
        return SeedsApiFp(this.configuration).listSeeds(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a seed
     * @param {} seedId Seed id
     * @param {} seed Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeedsApi
     */
    public updateSeed(seedId: string, seed: Seed, options?: any) {
        return SeedsApiFp(this.configuration).updateSeed(seedId, seed, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamsApi - fetch parameter creator
 * @export
 */
export const TeamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new team
         * @param {Team} team Team to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(team: Team, options: any = {}): FetchArgs {
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling createTeam.');
            }
            const path = `/v1/teams`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(team || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a team
         * @param {string} teamId Team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling deleteTeam.');
            }
            const path = `/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, String(teamId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find a team
         * @param {string} teamId Team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTeam(teamId: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling findTeam.');
            }
            const path = `/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, String(teamId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all teams
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/teams`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates a team
         * @param {string} teamId Team id
         * @param {Team} team Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId: string, team: Team, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling updateTeam.');
            }
            const path = `/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, String(teamId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(team || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new team
         * @param {Team} team Team to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(team: Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const fetchArgs = TeamsApiFetchParamCreator(configuration).createTeam(team, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a team
         * @param {string} teamId Team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = TeamsApiFetchParamCreator(configuration).deleteTeam(teamId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a team
         * @param {string} teamId Team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTeam(teamId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const fetchArgs = TeamsApiFetchParamCreator(configuration).findTeam(teamId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all teams
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const fetchArgs = TeamsApiFetchParamCreator(configuration).listTeams(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a team
         * @param {string} teamId Team id
         * @param {Team} team Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId: string, team: Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const fetchArgs = TeamsApiFetchParamCreator(configuration).updateTeam(teamId, team, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new team
         * @param {Team} team Team to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(team: Team, options?: any) {
            return TeamsApiFp(configuration).createTeam(team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a team
         * @param {string} teamId Team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId: string, options?: any) {
            return TeamsApiFp(configuration).deleteTeam(teamId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a team
         * @param {string} teamId Team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTeam(teamId: string, options?: any) {
            return TeamsApiFp(configuration).findTeam(teamId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all teams
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(firstResult?: number, maxResults?: number, options?: any) {
            return TeamsApiFp(configuration).listTeams(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a team
         * @param {string} teamId Team id
         * @param {Team} team Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId: string, team: Team, options?: any) {
            return TeamsApiFp(configuration).updateTeam(teamId, team, options)(fetch, basePath);
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * 
     * @summary Create new team
     * @param {} team Team to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public createTeam(team: Team, options?: any) {
        return TeamsApiFp(this.configuration).createTeam(team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a team
     * @param {} teamId Team id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeam(teamId: string, options?: any) {
        return TeamsApiFp(this.configuration).deleteTeam(teamId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a team
     * @param {} teamId Team id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public findTeam(teamId: string, options?: any) {
        return TeamsApiFp(this.configuration).findTeam(teamId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all teams
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public listTeams(firstResult?: number, maxResults?: number, options?: any) {
        return TeamsApiFp(this.configuration).listTeams(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a team
     * @param {} teamId Team id
     * @param {} team Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeam(teamId: string, team: Team, options?: any) {
        return TeamsApiFp(this.configuration).updateTeam(teamId, team, options)(this.fetch, this.basePath);
    }

}

/**
 * WastageReasonsApi - fetch parameter creator
 * @export
 */
export const WastageReasonsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new wastage reason
         * @param {WastageReason} wastageReason Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWastageReason(wastageReason: WastageReason, options: any = {}): FetchArgs {
            // verify required parameter 'wastageReason' is not null or undefined
            if (wastageReason === null || wastageReason === undefined) {
                throw new RequiredError('wastageReason','Required parameter wastageReason was null or undefined when calling createWastageReason.');
            }
            const path = `/v1/wastageReasons`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(wastageReason || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an wastage reason
         * @param {string} wastageReasonId WastageReasonId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWastageReason(wastageReasonId: string, options: any = {}): FetchArgs {
            // verify required parameter 'wastageReasonId' is not null or undefined
            if (wastageReasonId === null || wastageReasonId === undefined) {
                throw new RequiredError('wastageReasonId','Required parameter wastageReasonId was null or undefined when calling deleteWastageReason.');
            }
            const path = `/v1/wastageReasons/{wastageReasonId}`
                .replace(`{${"wastageReasonId"}}`, String(wastageReasonId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Find an wastage reason
         * @param {string} wastageReasonId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWastageReason(wastageReasonId: string, options: any = {}): FetchArgs {
            // verify required parameter 'wastageReasonId' is not null or undefined
            if (wastageReasonId === null || wastageReasonId === undefined) {
                throw new RequiredError('wastageReasonId','Required parameter wastageReasonId was null or undefined when calling findWastageReason.');
            }
            const path = `/v1/wastageReasons/{wastageReasonId}`
                .replace(`{${"wastageReasonId"}}`, String(wastageReasonId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary List all wastage reasons
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWastageReasons(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/v1/wastageReasons`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * 
         * @summary Updates an wastage reason
         * @param {string} wastageReasonId Wastage reason id
         * @param {WastageReason} wastageReason Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWastageReason(wastageReasonId: string, wastageReason: WastageReason, options: any = {}): FetchArgs {
            // verify required parameter 'wastageReasonId' is not null or undefined
            if (wastageReasonId === null || wastageReasonId === undefined) {
                throw new RequiredError('wastageReasonId','Required parameter wastageReasonId was null or undefined when calling updateWastageReason.');
            }
            // verify required parameter 'wastageReason' is not null or undefined
            if (wastageReason === null || wastageReason === undefined) {
                throw new RequiredError('wastageReason','Required parameter wastageReason was null or undefined when calling updateWastageReason.');
            }
            const path = `/v1/wastageReasons/{wastageReasonId}`
                .replace(`{${"wastageReasonId"}}`, String(wastageReasonId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                headerParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(wastageReason || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * WastageReasonsApi - functional programming interface
 * @export
 */
export const WastageReasonsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new wastage reason
         * @param {WastageReason} wastageReason Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWastageReason(wastageReason: WastageReason, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WastageReason> {
            const fetchArgs = WastageReasonsApiFetchParamCreator(configuration).createWastageReason(wastageReason, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes an wastage reason
         * @param {string} wastageReasonId WastageReasonId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWastageReason(wastageReasonId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = WastageReasonsApiFetchParamCreator(configuration).deleteWastageReason(wastageReasonId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find an wastage reason
         * @param {string} wastageReasonId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWastageReason(wastageReasonId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WastageReason> {
            const fetchArgs = WastageReasonsApiFetchParamCreator(configuration).findWastageReason(wastageReasonId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all wastage reasons
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWastageReasons(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WastageReason>> {
            const fetchArgs = WastageReasonsApiFetchParamCreator(configuration).listWastageReasons(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an wastage reason
         * @param {string} wastageReasonId Wastage reason id
         * @param {WastageReason} wastageReason Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWastageReason(wastageReasonId: string, wastageReason: WastageReason, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WastageReason> {
            const fetchArgs = WastageReasonsApiFetchParamCreator(configuration).updateWastageReason(wastageReasonId, wastageReason, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WastageReasonsApi - factory interface
 * @export
 */
export const WastageReasonsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new wastage reason
         * @param {WastageReason} wastageReason Wastage reason to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWastageReason(wastageReason: WastageReason, options?: any) {
            return WastageReasonsApiFp(configuration).createWastageReason(wastageReason, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes an wastage reason
         * @param {string} wastageReasonId WastageReasonId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWastageReason(wastageReasonId: string, options?: any) {
            return WastageReasonsApiFp(configuration).deleteWastageReason(wastageReasonId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find an wastage reason
         * @param {string} wastageReasonId Wastage reason id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWastageReason(wastageReasonId: string, options?: any) {
            return WastageReasonsApiFp(configuration).findWastageReason(wastageReasonId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all wastage reasons
         * @param {number} [firstResult] First index of results to be returned
         * @param {number} [maxResults] How many items to return at one time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWastageReasons(firstResult?: number, maxResults?: number, options?: any) {
            return WastageReasonsApiFp(configuration).listWastageReasons(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an wastage reason
         * @param {string} wastageReasonId Wastage reason id
         * @param {WastageReason} wastageReason Request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWastageReason(wastageReasonId: string, wastageReason: WastageReason, options?: any) {
            return WastageReasonsApiFp(configuration).updateWastageReason(wastageReasonId, wastageReason, options)(fetch, basePath);
        },
    };
};

/**
 * WastageReasonsApi - object-oriented interface
 * @export
 * @class WastageReasonsApi
 * @extends {BaseAPI}
 */
export class WastageReasonsApi extends BaseAPI {
    /**
     * 
     * @summary Create new wastage reason
     * @param {} wastageReason Wastage reason to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WastageReasonsApi
     */
    public createWastageReason(wastageReason: WastageReason, options?: any) {
        return WastageReasonsApiFp(this.configuration).createWastageReason(wastageReason, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes an wastage reason
     * @param {} wastageReasonId WastageReasonId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WastageReasonsApi
     */
    public deleteWastageReason(wastageReasonId: string, options?: any) {
        return WastageReasonsApiFp(this.configuration).deleteWastageReason(wastageReasonId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find an wastage reason
     * @param {} wastageReasonId Wastage reason id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WastageReasonsApi
     */
    public findWastageReason(wastageReasonId: string, options?: any) {
        return WastageReasonsApiFp(this.configuration).findWastageReason(wastageReasonId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all wastage reasons
     * @param {} [firstResult] First index of results to be returned
     * @param {} [maxResults] How many items to return at one time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WastageReasonsApi
     */
    public listWastageReasons(firstResult?: number, maxResults?: number, options?: any) {
        return WastageReasonsApiFp(this.configuration).listWastageReasons(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an wastage reason
     * @param {} wastageReasonId Wastage reason id
     * @param {} wastageReason Request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WastageReasonsApi
     */
    public updateWastageReason(wastageReasonId: string, wastageReason: WastageReason, options?: any) {
        return WastageReasonsApiFp(this.configuration).updateWastageReason(wastageReasonId, wastageReason, options)(this.fetch, this.basePath);
    }

}

