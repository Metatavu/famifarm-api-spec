/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Joints Tulistop Pro+ API
 * Joints Tulistop Pro+ API
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";

const portableFetch = fetch;
const BASE_PATH = "https://localhost/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * The error message
     * @type {string}
     * @memberof BadRequest
     */
    message: string;
}

/**
 * 
 * @export
 * @interface Conflict
 */
export interface Conflict {
    /**
     * The error message
     * @type {string}
     * @memberof Conflict
     */
    message: string;
}

/**
 * 
 * @export
 * @interface Detail
 */
export interface Detail {
    /**
     * Id of the detail
     * @type {string}
     * @memberof Detail
     */
    id?: string;
    /**
     * name of the detail
     * @type {string}
     * @memberof Detail
     */
    name: string;
    /**
     * Detail number
     * @type {string}
     * @memberof Detail
     */
    detailNumber: string;
    /**
     * Type of deail conduit
     * @type {string}
     * @memberof Detail
     */
    conduitType?: string;
    /**
     * todo
     * @type {string}
     * @memberof Detail
     */
    size?: string;
    /**
     * todo
     * @type {string}
     * @memberof Detail
     */
    classification?: string;
    /**
     * 
     * @type {string}
     * @memberof Detail
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Detail
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof Detail
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof Detail
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface DetailLocation
 */
export interface DetailLocation {
    /**
     * Id of the detail location
     * @type {string}
     * @memberof DetailLocation
     */
    id?: string;
    /**
     * x coordinate of the location
     * @type {number}
     * @memberof DetailLocation
     */
    x: number;
    /**
     * y coordinate of the location
     * @type {number}
     * @memberof DetailLocation
     */
    y: number;
    /**
     * ID of schematic
     * @type {string}
     * @memberof DetailLocation
     */
    siteSchematicId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailLocation
     */
    status: DetailLocation.StatusEnum;
    /**
     * Id of the worker
     * @type {string}
     * @memberof DetailLocation
     */
    workerId?: string;
    /**
     * Id of the planner
     * @type {string}
     * @memberof DetailLocation
     */
    plannerId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailLocation
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailLocation
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof DetailLocation
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof DetailLocation
     */
    modifiedAt?: string;
}

/**
 * @export
 * @namespace DetailLocation
 */
export namespace DetailLocation {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PLANNED = <any> 'PLANNED',
        REVIEW = <any> 'REVIEW',
        DONE = <any> 'DONE',
        APPROVED = <any> 'APPROVED'
    }
}

/**
 * 
 * @export
 * @interface DetailLocationNote
 */
export interface DetailLocationNote {
    /**
     * Content of the note
     * @type {string}
     * @memberof DetailLocationNote
     */
    content?: string;
    /**
     * Id of the user who left the note
     * @type {string}
     * @memberof DetailLocationNote
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailLocationNote
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailLocationNote
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof DetailLocationNote
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof DetailLocationNote
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface DetailSchematic
 */
export interface DetailSchematic {
    /**
     * ID of detail schematic
     * @type {string}
     * @memberof DetailSchematic
     */
    id?: string;
    /**
     * ID of schematic file
     * @type {string}
     * @memberof DetailSchematic
     */
    fileId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailSchematic
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailSchematic
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof DetailSchematic
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof DetailSchematic
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface Forbidden
 */
export interface Forbidden {
    /**
     * The error message
     * @type {string}
     * @memberof Forbidden
     */
    message: string;
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * ID of image
     * @type {string}
     * @memberof Image
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    small?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    medium?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    large?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    raw?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    creatorId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof Image
     */
    createdAt?: string;
}

/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * The error message
     * @type {string}
     * @memberof InternalServerError
     */
    message: string;
}

/**
 * 
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     * The error message
     * @type {string}
     * @memberof NotFound
     */
    message: string;
}

/**
 * 
 * @export
 * @interface NotImplemented
 */
export interface NotImplemented {
    /**
     * The error message
     * @type {string}
     * @memberof NotImplemented
     */
    message: string;
}

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name: string;
    /**
     * Whether the product is custom or not
     * @type {boolean}
     * @memberof Product
     */
    custom: boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof Product
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof Product
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface Realm
 */
export interface Realm {
    /**
     * 
     * @type {string}
     * @memberof Realm
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Realm
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Realm
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Realm
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Realm
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof Realm
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof Realm
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    id?: string;
    /**
     * Address of the site
     * @type {string}
     * @memberof Site
     */
    address: string;
    /**
     * Customer of the site
     * @type {string}
     * @memberof Site
     */
    customer: string;
    /**
     * Status of the site
     * @type {string}
     * @memberof Site
     */
    status: Site.StatusEnum;
    /**
     * Sites archivement date
     * @type {string}
     * @memberof Site
     */
    archivementDate?: string;
    /**
     * Sites description
     * @type {string}
     * @memberof Site
     */
    description?: string;
    /**
     * Officials comment
     * @type {string}
     * @memberof Site
     */
    officialsComment?: string;
    /**
     * TODO
     * @type {string}
     * @memberof Site
     */
    operation?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof Site
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof Site
     */
    modifiedAt?: string;
}

/**
 * @export
 * @namespace Site
 */
export namespace Site {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        OPEN = <any> 'OPEN',
        ARCHIVED = <any> 'ARCHIVED'
    }
}

/**
 * 
 * @export
 * @interface SiteSchematic
 */
export interface SiteSchematic {
    /**
     * ID of site schematic
     * @type {string}
     * @memberof SiteSchematic
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteSchematic
     */
    status?: SiteSchematic.StatusEnum;
    /**
     * TODO
     * @type {string}
     * @memberof SiteSchematic
     */
    type?: string;
    /**
     * Sites schematic scale
     * @type {string}
     * @memberof SiteSchematic
     */
    scale?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteSchematic
     */
    fileId?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteSchematic
     */
    creatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteSchematic
     */
    lastModifierId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof SiteSchematic
     */
    createdAt?: string;
    /**
     * Date modified
     * @type {string}
     * @memberof SiteSchematic
     */
    modifiedAt?: string;
}

/**
 * @export
 * @namespace SiteSchematic
 */
export namespace SiteSchematic {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PROCESSING = <any> 'PROCESSING',
        ERROR = <any> 'ERROR',
        READY = <any> 'READY'
    }
}

/**
 * 
 * @export
 * @interface SiteUser
 */
export interface SiteUser {
    /**
     * 
     * @type {string}
     * @memberof SiteUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUser
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUser
     */
    role: SiteUser.RoleEnum;
}

/**
 * @export
 * @namespace SiteUser
 */
export namespace SiteUser {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        WORKER = <any> 'WORKER',
        PLANNER = <any> 'PLANNER'
    }
}

/**
 * 
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
    /**
     * The error message
     * @type {string}
     * @memberof Unauthorized
     */
    message: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof User
     */
    role?: UserRole;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum UserRole {
    USER = <any> 'USER',
    PLANNER = <any> 'PLANNER'
}


/**
 * ProductsApi - fetch parameter creator
 * @export
 */
export const ProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new product
         * @summary Create product
         * @param {Product} body The realm to be created
         * @param {string} realmId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(body: Product, realmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProduct.');
            }
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createProduct.');
            }
            const localVarPath = `/realms/{realmId}/products`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product
         * @summary Delete product
         * @param {string} realmId The id of the realm being deleted
         * @param {string} productId The id of the realm being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(realmId: string, productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteProduct.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProduct.');
            }
            const localVarPath = `/realms/{realmId}/products/{productId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a product
         * @summary Finds product
         * @param {string} realmId The id of the realm
         * @param {string} productId The id of the realm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(realmId: string, productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findProduct.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling findProduct.');
            }
            const localVarPath = `/realms/{realmId}/products/{productId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds all products by id
         * @summary Finds products by id
         * @param {string} realmId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(realmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listProducts.');
            }
            const localVarPath = `/realms/{realmId}/products`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product
         * @summary Update product
         * @param {string} realmId The realm to be updated
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(realmId: string, productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateProduct.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProduct.');
            }
            const localVarPath = `/realms/{realmId}/products/{productId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new product
         * @summary Create product
         * @param {Product} body The realm to be created
         * @param {string} realmId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(body: Product, realmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).createProduct(body, realmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a product
         * @summary Delete product
         * @param {string} realmId The id of the realm being deleted
         * @param {string} productId The id of the realm being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(realmId: string, productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).deleteProduct(realmId, productId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a product
         * @summary Finds product
         * @param {string} realmId The id of the realm
         * @param {string} productId The id of the realm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(realmId: string, productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).findProduct(realmId, productId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds all products by id
         * @summary Finds products by id
         * @param {string} realmId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(realmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Product>> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).listProducts(realmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a product
         * @summary Update product
         * @param {string} realmId The realm to be updated
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(realmId: string, productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).updateProduct(realmId, productId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new product
         * @summary Create product
         * @param {Product} body The realm to be created
         * @param {string} realmId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(body: Product, realmId: string, options?: any) {
            return ProductsApiFp(configuration).createProduct(body, realmId, options)(fetch, basePath);
        },
        /**
         * Deletes a product
         * @summary Delete product
         * @param {string} realmId The id of the realm being deleted
         * @param {string} productId The id of the realm being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(realmId: string, productId: string, options?: any) {
            return ProductsApiFp(configuration).deleteProduct(realmId, productId, options)(fetch, basePath);
        },
        /**
         * Finds a product
         * @summary Finds product
         * @param {string} realmId The id of the realm
         * @param {string} productId The id of the realm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(realmId: string, productId: string, options?: any) {
            return ProductsApiFp(configuration).findProduct(realmId, productId, options)(fetch, basePath);
        },
        /**
         * Finds all products by id
         * @summary Finds products by id
         * @param {string} realmId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(realmId: string, options?: any) {
            return ProductsApiFp(configuration).listProducts(realmId, options)(fetch, basePath);
        },
        /**
         * Updates a product
         * @summary Update product
         * @param {string} realmId The realm to be updated
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(realmId: string, productId: string, options?: any) {
            return ProductsApiFp(configuration).updateProduct(realmId, productId, options)(fetch, basePath);
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Creates new product
     * @summary Create product
     * @param {Product} body The realm to be created
     * @param {string} realmId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(body: Product, realmId: string, options?: any) {
        return ProductsApiFp(this.configuration).createProduct(body, realmId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a product
     * @summary Delete product
     * @param {string} realmId The id of the realm being deleted
     * @param {string} productId The id of the realm being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(realmId: string, productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProduct(realmId, productId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a product
     * @summary Finds product
     * @param {string} realmId The id of the realm
     * @param {string} productId The id of the realm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public findProduct(realmId: string, productId: string, options?: any) {
        return ProductsApiFp(this.configuration).findProduct(realmId, productId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds all products by id
     * @summary Finds products by id
     * @param {string} realmId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(realmId: string, options?: any) {
        return ProductsApiFp(this.configuration).listProducts(realmId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a product
     * @summary Update product
     * @param {string} realmId The realm to be updated
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(realmId: string, productId: string, options?: any) {
        return ProductsApiFp(this.configuration).updateProduct(realmId, productId, options)(this.fetch, this.basePath);
    }

}

/**
 * RealmsApi - fetch parameter creator
 * @export
 */
export const RealmsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new realm
         * @summary Create realm
         * @param {string} adminEmail Initial realm admin email
         * @param {string} adminPassword Initial realm admin password
         * @param {Realm} body The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRealm(adminEmail: string, adminPassword: string, body: Realm, options: any = {}): FetchArgs {
            // verify required parameter 'adminEmail' is not null or undefined
            if (adminEmail === null || adminEmail === undefined) {
                throw new RequiredError('adminEmail','Required parameter adminEmail was null or undefined when calling createRealm.');
            }
            // verify required parameter 'adminPassword' is not null or undefined
            if (adminPassword === null || adminPassword === undefined) {
                throw new RequiredError('adminPassword','Required parameter adminPassword was null or undefined when calling createRealm.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRealm.');
            }
            const localVarPath = `/realms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (adminEmail !== undefined) {
                localVarQueryParameter['admin-email'] = adminEmail;
            }

            if (adminPassword !== undefined) {
                localVarQueryParameter['admin-password'] = adminPassword;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Realm" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a realm
         * @summary Delete realm
         * @param {string} realmId The id of the realm being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRealm(realmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteRealm.');
            }
            const localVarPath = `/realms/{realmId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a realm
         * @summary Finds realm
         * @param {string} realmId The id of the realm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRealm(realmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findRealm.');
            }
            const localVarPath = `/realms/{realmId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists realms
         * @summary Lists realms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealms(options: any = {}): FetchArgs {
            const localVarPath = `/realms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a realm
         * @summary Update realm
         * @param {string} realmId The realm to be updated
         * @param {Realm} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealm(realmId: string, payload: Realm, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateRealm.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateRealm.');
            }
            const localVarPath = `/realms/{realmId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Realm" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealmsApi - functional programming interface
 * @export
 */
export const RealmsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new realm
         * @summary Create realm
         * @param {string} adminEmail Initial realm admin email
         * @param {string} adminPassword Initial realm admin password
         * @param {Realm} body The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRealm(adminEmail: string, adminPassword: string, body: Realm, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Realm> {
            const localVarFetchArgs = RealmsApiFetchParamCreator(configuration).createRealm(adminEmail, adminPassword, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a realm
         * @summary Delete realm
         * @param {string} realmId The id of the realm being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRealm(realmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RealmsApiFetchParamCreator(configuration).deleteRealm(realmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a realm
         * @summary Finds realm
         * @param {string} realmId The id of the realm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRealm(realmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Realm> {
            const localVarFetchArgs = RealmsApiFetchParamCreator(configuration).findRealm(realmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists realms
         * @summary Lists realms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealms(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Realm>> {
            const localVarFetchArgs = RealmsApiFetchParamCreator(configuration).listRealms(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a realm
         * @summary Update realm
         * @param {string} realmId The realm to be updated
         * @param {Realm} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealm(realmId: string, payload: Realm, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Realm> {
            const localVarFetchArgs = RealmsApiFetchParamCreator(configuration).updateRealm(realmId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RealmsApi - factory interface
 * @export
 */
export const RealmsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new realm
         * @summary Create realm
         * @param {string} adminEmail Initial realm admin email
         * @param {string} adminPassword Initial realm admin password
         * @param {Realm} body The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRealm(adminEmail: string, adminPassword: string, body: Realm, options?: any) {
            return RealmsApiFp(configuration).createRealm(adminEmail, adminPassword, body, options)(fetch, basePath);
        },
        /**
         * Deletes a realm
         * @summary Delete realm
         * @param {string} realmId The id of the realm being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRealm(realmId: string, options?: any) {
            return RealmsApiFp(configuration).deleteRealm(realmId, options)(fetch, basePath);
        },
        /**
         * Finds a realm
         * @summary Finds realm
         * @param {string} realmId The id of the realm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRealm(realmId: string, options?: any) {
            return RealmsApiFp(configuration).findRealm(realmId, options)(fetch, basePath);
        },
        /**
         * Lists realms
         * @summary Lists realms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealms(options?: any) {
            return RealmsApiFp(configuration).listRealms(options)(fetch, basePath);
        },
        /**
         * Updates a realm
         * @summary Update realm
         * @param {string} realmId The realm to be updated
         * @param {Realm} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealm(realmId: string, payload: Realm, options?: any) {
            return RealmsApiFp(configuration).updateRealm(realmId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * RealmsApi - object-oriented interface
 * @export
 * @class RealmsApi
 * @extends {BaseAPI}
 */
export class RealmsApi extends BaseAPI {
    /**
     * Creates new realm
     * @summary Create realm
     * @param {string} adminEmail Initial realm admin email
     * @param {string} adminPassword Initial realm admin password
     * @param {Realm} body The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmsApi
     */
    public createRealm(adminEmail: string, adminPassword: string, body: Realm, options?: any) {
        return RealmsApiFp(this.configuration).createRealm(adminEmail, adminPassword, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a realm
     * @summary Delete realm
     * @param {string} realmId The id of the realm being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmsApi
     */
    public deleteRealm(realmId: string, options?: any) {
        return RealmsApiFp(this.configuration).deleteRealm(realmId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a realm
     * @summary Finds realm
     * @param {string} realmId The id of the realm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmsApi
     */
    public findRealm(realmId: string, options?: any) {
        return RealmsApiFp(this.configuration).findRealm(realmId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists realms
     * @summary Lists realms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmsApi
     */
    public listRealms(options?: any) {
        return RealmsApiFp(this.configuration).listRealms(options)(this.fetch, this.basePath);
    }

    /**
     * Updates a realm
     * @summary Update realm
     * @param {string} realmId The realm to be updated
     * @param {Realm} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmsApi
     */
    public updateRealm(realmId: string, payload: Realm, options?: any) {
        return RealmsApiFp(this.configuration).updateRealm(realmId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * SiteDetailsApi - fetch parameter creator
 * @export
 */
export const SiteDetailsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new site detail
         * @summary Create site detail
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {Detail} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetail(realmId: string, siteId: string, payload: Detail, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteDetail.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteDetail.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createSiteDetail.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Detail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new site detail location
         * @summary Create site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {DetailLocation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocation(realmId: string, siteId: string, detailId: string, body: DetailLocation, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteDetailLocation.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteDetailLocation.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling createSiteDetailLocation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSiteDetailLocation.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailLocation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new site detail location image
         * @summary Create site detail location image
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {Image} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, body: Image, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteDetailLocationImage.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteDetailLocationImage.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling createSiteDetailLocationImage.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createSiteDetailLocationImage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSiteDetailLocationImage.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/images`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Image" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new site detail location note
         * @summary Create site detail location note
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {DetailLocationNote} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocationNote, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteDetailLocationNote.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteDetailLocationNote.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling createSiteDetailLocationNote.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createSiteDetailLocationNote.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSiteDetailLocationNote.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/notes`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailLocationNote" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new site detail shemantic
         * @summary Create site detail shemantic
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {DetailSchematic} detailSchematic Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailSchematic(realmId: string, siteId: string, detailId: string, detailSchematic: DetailSchematic, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteDetailSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteDetailSchematic.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling createSiteDetailSchematic.');
            }
            // verify required parameter 'detailSchematic' is not null or undefined
            if (detailSchematic === null || detailSchematic === undefined) {
                throw new RequiredError('detailSchematic','Required parameter detailSchematic was null or undefined when calling createSiteDetailSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/schematics`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailSchematic" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(detailSchematic || {}) : (detailSchematic || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a detail schematic
         * @summary Delete detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteDetailSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteDetailSchematic.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling deleteDetailSchematic.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling deleteDetailSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/schematics/{schematicId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a detail
         * @summary Delete detail
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetail(realmId: string, siteId: string, detailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteDetail.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteDetail.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling deleteSiteDetail.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site detail location
         * @summary Delete site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteDetailLocation.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteDetailLocation.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling deleteSiteDetailLocation.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteSiteDetailLocation.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site detail location image
         * @summary Delete site detail location image
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteDetailLocationImage.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteDetailLocationImage.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling deleteSiteDetailLocationImage.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteSiteDetailLocationImage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling deleteSiteDetailLocationImage.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/images/{imageId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site detail location note
         * @summary Delete site detail location note
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteDetailLocationNote.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteDetailLocationNote.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling deleteSiteDetailLocationNote.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteSiteDetailLocationNote.');
            }
            // verify required parameter 'noteId' is not null or undefined
            if (noteId === null || noteId === undefined) {
                throw new RequiredError('noteId','Required parameter noteId was null or undefined when calling deleteSiteDetailLocationNote.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/notes/{noteId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site report
         * @summary Delete site report
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} reportType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteReport(realmId: string, siteId: string, reportType: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteReport.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteReport.');
            }
            // verify required parameter 'reportType' is not null or undefined
            if (reportType === null || reportType === undefined) {
                throw new RequiredError('reportType','Required parameter reportType was null or undefined when calling deleteSiteReport.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/reports/{reportType}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"reportType"}}`, encodeURIComponent(String(reportType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site detail
         * @summary Finds site detail
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetail(realmId: string, siteId: string, detailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteDetail.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteDetail.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling findSiteDetail.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site detail location
         * @summary Finds site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteDetailLocation.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteDetailLocation.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling findSiteDetailLocation.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling findSiteDetailLocation.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site detail location image
         * @summary Finds site detail location image
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} imageId 
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, imageId: string, locationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteDetailLocationImage.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteDetailLocationImage.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling findSiteDetailLocationImage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling findSiteDetailLocationImage.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling findSiteDetailLocationImage.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/images/{imageId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site detail location note
         * @summary Finds site detail location note
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {string} noteId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteDetailLocationNote.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteDetailLocationNote.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling findSiteDetailLocationNote.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling findSiteDetailLocationNote.');
            }
            // verify required parameter 'noteId' is not null or undefined
            if (noteId === null || noteId === undefined) {
                throw new RequiredError('noteId','Required parameter noteId was null or undefined when calling findSiteDetailLocationNote.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/notes/{noteId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site detail schematic
         * @summary Finds site detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteDetailSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteDetailSchematic.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling findSiteDetailSchematic.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling findSiteDetailSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/schematics/{schematicId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site detail schematic data
         * @summary Finds site detail schematic data
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailSchematicData(realmId: string, siteId: string, schematicId: string, detailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteDetailSchematicData.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteDetailSchematicData.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling findSiteDetailSchematicData.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling findSiteDetailSchematicData.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/schematics/{schematicId}/data`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds all site detail location notes
         * @summary Finds site detail location notes
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteDetailLocationNotes(realmId: string, siteId: string, detailId: string, locationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling getSiteDetailLocationNotes.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling getSiteDetailLocationNotes.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling getSiteDetailLocationNotes.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling getSiteDetailLocationNotes.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/notes`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds all site detail location images
         * @summary Finds site detail location images
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailLocationImages(realmId: string, siteId: string, detailId: string, locationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSiteDetailLocationImages.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling listSiteDetailLocationImages.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling listSiteDetailLocationImages.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listSiteDetailLocationImages.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/images`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds all site detail locations
         * @summary Finds site detail locations
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} [siteSchematicId] Filter results by site schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailLocations(realmId: string, siteId: string, detailId: string, siteSchematicId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSiteDetailLocations.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling listSiteDetailLocations.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling listSiteDetailLocations.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (siteSchematicId !== undefined) {
                localVarQueryParameter['siteSchematicId'] = siteSchematicId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds all sites detail schematics
         * @summary Finds sites detail schematics
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {string} detailId The id of detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailSchematics(realmId: string, siteId: string, detailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSiteDetailSchematics.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling listSiteDetailSchematics.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling listSiteDetailSchematics.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/schematics`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds all sites details
         * @summary Finds sites details
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetails(realmId: string, siteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSiteDetails.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling listSiteDetails.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a detail schematic
         * @summary Update detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {DetailSchematic} detailSchematic Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, detailSchematic: DetailSchematic, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateDetailSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateDetailSchematic.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling updateDetailSchematic.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling updateDetailSchematic.');
            }
            // verify required parameter 'detailSchematic' is not null or undefined
            if (detailSchematic === null || detailSchematic === undefined) {
                throw new RequiredError('detailSchematic','Required parameter detailSchematic was null or undefined when calling updateDetailSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/schematics/{schematicId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailSchematic" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(detailSchematic || {}) : (detailSchematic || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a detail
         * @summary Update detail
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} detailId The id of the detail
         * @param {Detail} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetail(realmId: string, siteId: string, detailId: string, payload: Detail, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSiteDetail.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSiteDetail.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling updateSiteDetail.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateSiteDetail.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Detail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a site detail location
         * @summary Update site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {DetailLocation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocation, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSiteDetailLocation.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSiteDetailLocation.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling updateSiteDetailLocation.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateSiteDetailLocation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSiteDetailLocation.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailLocation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a site detail location image
         * @summary Update site detail location image
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} imageId 
         * @param {Image} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, body: Image, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSiteDetailLocationImage.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSiteDetailLocationImage.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling updateSiteDetailLocationImage.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateSiteDetailLocationImage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling updateSiteDetailLocationImage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSiteDetailLocationImage.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/images/{imageId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Image" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a site detail location note
         * @summary Update site detail location note
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} noteId 
         * @param {DetailLocationNote} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, body: DetailLocationNote, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSiteDetailLocationNote.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSiteDetailLocationNote.');
            }
            // verify required parameter 'detailId' is not null or undefined
            if (detailId === null || detailId === undefined) {
                throw new RequiredError('detailId','Required parameter detailId was null or undefined when calling updateSiteDetailLocationNote.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateSiteDetailLocationNote.');
            }
            // verify required parameter 'noteId' is not null or undefined
            if (noteId === null || noteId === undefined) {
                throw new RequiredError('noteId','Required parameter noteId was null or undefined when calling updateSiteDetailLocationNote.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSiteDetailLocationNote.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/details/{detailId}/locations/{locationId}/notes/{noteId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"detailId"}}`, encodeURIComponent(String(detailId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailLocationNote" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteDetailsApi - functional programming interface
 * @export
 */
export const SiteDetailsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new site detail
         * @summary Create site detail
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {Detail} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetail(realmId: string, siteId: string, payload: Detail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Detail> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).createSiteDetail(realmId, siteId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates new site detail location
         * @summary Create site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {DetailLocation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocation(realmId: string, siteId: string, detailId: string, body: DetailLocation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailLocation> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).createSiteDetailLocation(realmId, siteId, detailId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates new site detail location image
         * @summary Create site detail location image
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {Image} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, body: Image, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Image> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).createSiteDetailLocationImage(realmId, siteId, detailId, locationId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates new site detail location note
         * @summary Create site detail location note
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {DetailLocationNote} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocationNote, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailLocationNote> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).createSiteDetailLocationNote(realmId, siteId, detailId, locationId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates new site detail shemantic
         * @summary Create site detail shemantic
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {DetailSchematic} detailSchematic Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailSchematic(realmId: string, siteId: string, detailId: string, detailSchematic: DetailSchematic, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailSchematic> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).createSiteDetailSchematic(realmId, siteId, detailId, detailSchematic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a detail schematic
         * @summary Delete detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).deleteDetailSchematic(realmId, siteId, schematicId, detailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a detail
         * @summary Delete detail
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetail(realmId: string, siteId: string, detailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).deleteSiteDetail(realmId, siteId, detailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site detail location
         * @summary Delete site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).deleteSiteDetailLocation(realmId, siteId, detailId, locationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site detail location image
         * @summary Delete site detail location image
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).deleteSiteDetailLocationImage(realmId, siteId, detailId, locationId, imageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site detail location note
         * @summary Delete site detail location note
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).deleteSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site report
         * @summary Delete site report
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} reportType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteReport(realmId: string, siteId: string, reportType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).deleteSiteReport(realmId, siteId, reportType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site detail
         * @summary Finds site detail
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetail(realmId: string, siteId: string, detailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Detail> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).findSiteDetail(realmId, siteId, detailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site detail location
         * @summary Finds site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailLocation> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).findSiteDetailLocation(realmId, siteId, detailId, locationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site detail location image
         * @summary Finds site detail location image
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} imageId 
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, imageId: string, locationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Image> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).findSiteDetailLocationImage(realmId, siteId, detailId, imageId, locationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site detail location note
         * @summary Finds site detail location note
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {string} noteId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailLocationNote> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).findSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site detail schematic
         * @summary Finds site detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailSchematic> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).findSiteDetailSchematic(realmId, siteId, schematicId, detailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site detail schematic data
         * @summary Finds site detail schematic data
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailSchematicData(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).findSiteDetailSchematicData(realmId, siteId, schematicId, detailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds all site detail location notes
         * @summary Finds site detail location notes
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteDetailLocationNotes(realmId: string, siteId: string, detailId: string, locationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DetailLocationNote>> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).getSiteDetailLocationNotes(realmId, siteId, detailId, locationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds all site detail location images
         * @summary Finds site detail location images
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailLocationImages(realmId: string, siteId: string, detailId: string, locationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Image>> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).listSiteDetailLocationImages(realmId, siteId, detailId, locationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds all site detail locations
         * @summary Finds site detail locations
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} [siteSchematicId] Filter results by site schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailLocations(realmId: string, siteId: string, detailId: string, siteSchematicId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DetailLocation>> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).listSiteDetailLocations(realmId, siteId, detailId, siteSchematicId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds all sites detail schematics
         * @summary Finds sites detail schematics
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {string} detailId The id of detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailSchematics(realmId: string, siteId: string, detailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DetailSchematic>> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).listSiteDetailSchematics(realmId, siteId, detailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds all sites details
         * @summary Finds sites details
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetails(realmId: string, siteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Detail>> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).listSiteDetails(realmId, siteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a detail schematic
         * @summary Update detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {DetailSchematic} detailSchematic Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, detailSchematic: DetailSchematic, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailSchematic> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).updateDetailSchematic(realmId, siteId, schematicId, detailId, detailSchematic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a detail
         * @summary Update detail
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} detailId The id of the detail
         * @param {Detail} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetail(realmId: string, siteId: string, detailId: string, payload: Detail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Detail> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).updateSiteDetail(realmId, siteId, detailId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a site detail location
         * @summary Update site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {DetailLocation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailLocation> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).updateSiteDetailLocation(realmId, siteId, detailId, locationId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a site detail location image
         * @summary Update site detail location image
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} imageId 
         * @param {Image} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, body: Image, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Image> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).updateSiteDetailLocationImage(realmId, siteId, detailId, locationId, imageId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a site detail location note
         * @summary Update site detail location note
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} noteId 
         * @param {DetailLocationNote} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, body: DetailLocationNote, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailLocationNote> {
            const localVarFetchArgs = SiteDetailsApiFetchParamCreator(configuration).updateSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SiteDetailsApi - factory interface
 * @export
 */
export const SiteDetailsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new site detail
         * @summary Create site detail
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {Detail} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetail(realmId: string, siteId: string, payload: Detail, options?: any) {
            return SiteDetailsApiFp(configuration).createSiteDetail(realmId, siteId, payload, options)(fetch, basePath);
        },
        /**
         * Creates new site detail location
         * @summary Create site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {DetailLocation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocation(realmId: string, siteId: string, detailId: string, body: DetailLocation, options?: any) {
            return SiteDetailsApiFp(configuration).createSiteDetailLocation(realmId, siteId, detailId, body, options)(fetch, basePath);
        },
        /**
         * Creates new site detail location image
         * @summary Create site detail location image
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {Image} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, body: Image, options?: any) {
            return SiteDetailsApiFp(configuration).createSiteDetailLocationImage(realmId, siteId, detailId, locationId, body, options)(fetch, basePath);
        },
        /**
         * Creates new site detail location note
         * @summary Create site detail location note
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {DetailLocationNote} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocationNote, options?: any) {
            return SiteDetailsApiFp(configuration).createSiteDetailLocationNote(realmId, siteId, detailId, locationId, body, options)(fetch, basePath);
        },
        /**
         * Creates new site detail shemantic
         * @summary Create site detail shemantic
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {DetailSchematic} detailSchematic Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteDetailSchematic(realmId: string, siteId: string, detailId: string, detailSchematic: DetailSchematic, options?: any) {
            return SiteDetailsApiFp(configuration).createSiteDetailSchematic(realmId, siteId, detailId, detailSchematic, options)(fetch, basePath);
        },
        /**
         * Deletes a detail schematic
         * @summary Delete detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any) {
            return SiteDetailsApiFp(configuration).deleteDetailSchematic(realmId, siteId, schematicId, detailId, options)(fetch, basePath);
        },
        /**
         * Deletes a detail
         * @summary Delete detail
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetail(realmId: string, siteId: string, detailId: string, options?: any) {
            return SiteDetailsApiFp(configuration).deleteSiteDetail(realmId, siteId, detailId, options)(fetch, basePath);
        },
        /**
         * Deletes a site detail location
         * @summary Delete site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
            return SiteDetailsApiFp(configuration).deleteSiteDetailLocation(realmId, siteId, detailId, locationId, options)(fetch, basePath);
        },
        /**
         * Deletes a site detail location image
         * @summary Delete site detail location image
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, options?: any) {
            return SiteDetailsApiFp(configuration).deleteSiteDetailLocationImage(realmId, siteId, detailId, locationId, imageId, options)(fetch, basePath);
        },
        /**
         * Deletes a site detail location note
         * @summary Delete site detail location note
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options?: any) {
            return SiteDetailsApiFp(configuration).deleteSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, options)(fetch, basePath);
        },
        /**
         * Deletes a site report
         * @summary Delete site report
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} reportType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteReport(realmId: string, siteId: string, reportType: string, options?: any) {
            return SiteDetailsApiFp(configuration).deleteSiteReport(realmId, siteId, reportType, options)(fetch, basePath);
        },
        /**
         * Finds a site detail
         * @summary Finds site detail
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetail(realmId: string, siteId: string, detailId: string, options?: any) {
            return SiteDetailsApiFp(configuration).findSiteDetail(realmId, siteId, detailId, options)(fetch, basePath);
        },
        /**
         * Finds a site detail location
         * @summary Finds site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
            return SiteDetailsApiFp(configuration).findSiteDetailLocation(realmId, siteId, detailId, locationId, options)(fetch, basePath);
        },
        /**
         * Finds a site detail location image
         * @summary Finds site detail location image
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} imageId 
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, imageId: string, locationId: string, options?: any) {
            return SiteDetailsApiFp(configuration).findSiteDetailLocationImage(realmId, siteId, detailId, imageId, locationId, options)(fetch, basePath);
        },
        /**
         * Finds a site detail location note
         * @summary Finds site detail location note
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {string} noteId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options?: any) {
            return SiteDetailsApiFp(configuration).findSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, options)(fetch, basePath);
        },
        /**
         * Finds a site detail schematic
         * @summary Finds site detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any) {
            return SiteDetailsApiFp(configuration).findSiteDetailSchematic(realmId, siteId, schematicId, detailId, options)(fetch, basePath);
        },
        /**
         * Finds a site detail schematic data
         * @summary Finds site detail schematic data
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteDetailSchematicData(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any) {
            return SiteDetailsApiFp(configuration).findSiteDetailSchematicData(realmId, siteId, schematicId, detailId, options)(fetch, basePath);
        },
        /**
         * Finds all site detail location notes
         * @summary Finds site detail location notes
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteDetailLocationNotes(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
            return SiteDetailsApiFp(configuration).getSiteDetailLocationNotes(realmId, siteId, detailId, locationId, options)(fetch, basePath);
        },
        /**
         * Finds all site detail location images
         * @summary Finds site detail location images
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailLocationImages(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
            return SiteDetailsApiFp(configuration).listSiteDetailLocationImages(realmId, siteId, detailId, locationId, options)(fetch, basePath);
        },
        /**
         * Finds all site detail locations
         * @summary Finds site detail locations
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} [siteSchematicId] Filter results by site schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailLocations(realmId: string, siteId: string, detailId: string, siteSchematicId?: string, options?: any) {
            return SiteDetailsApiFp(configuration).listSiteDetailLocations(realmId, siteId, detailId, siteSchematicId, options)(fetch, basePath);
        },
        /**
         * Finds all sites detail schematics
         * @summary Finds sites detail schematics
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {string} detailId The id of detail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetailSchematics(realmId: string, siteId: string, detailId: string, options?: any) {
            return SiteDetailsApiFp(configuration).listSiteDetailSchematics(realmId, siteId, detailId, options)(fetch, basePath);
        },
        /**
         * Finds all sites details
         * @summary Finds sites details
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteDetails(realmId: string, siteId: string, options?: any) {
            return SiteDetailsApiFp(configuration).listSiteDetails(realmId, siteId, options)(fetch, basePath);
        },
        /**
         * Updates a detail schematic
         * @summary Update detail schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {string} detailId The id of the detail
         * @param {DetailSchematic} detailSchematic Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, detailSchematic: DetailSchematic, options?: any) {
            return SiteDetailsApiFp(configuration).updateDetailSchematic(realmId, siteId, schematicId, detailId, detailSchematic, options)(fetch, basePath);
        },
        /**
         * Updates a detail
         * @summary Update detail
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} detailId The id of the detail
         * @param {Detail} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetail(realmId: string, siteId: string, detailId: string, payload: Detail, options?: any) {
            return SiteDetailsApiFp(configuration).updateSiteDetail(realmId, siteId, detailId, payload, options)(fetch, basePath);
        },
        /**
         * Updates a site detail location
         * @summary Update site detail location
         * @param {string} realmId The realm to be created
         * @param {string} siteId The realm to be created
         * @param {string} detailId The realm to be created
         * @param {string} locationId The realm to be created
         * @param {DetailLocation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocation, options?: any) {
            return SiteDetailsApiFp(configuration).updateSiteDetailLocation(realmId, siteId, detailId, locationId, body, options)(fetch, basePath);
        },
        /**
         * Updates a site detail location image
         * @summary Update site detail location image
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} imageId 
         * @param {Image} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, body: Image, options?: any) {
            return SiteDetailsApiFp(configuration).updateSiteDetailLocationImage(realmId, siteId, detailId, locationId, imageId, body, options)(fetch, basePath);
        },
        /**
         * Updates a site detail location note
         * @summary Update site detail location note
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {string} detailId 
         * @param {string} locationId 
         * @param {string} noteId 
         * @param {DetailLocationNote} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, body: DetailLocationNote, options?: any) {
            return SiteDetailsApiFp(configuration).updateSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, body, options)(fetch, basePath);
        },
    };
};

/**
 * SiteDetailsApi - object-oriented interface
 * @export
 * @class SiteDetailsApi
 * @extends {BaseAPI}
 */
export class SiteDetailsApi extends BaseAPI {
    /**
     * Creates new site detail
     * @summary Create site detail
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {Detail} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public createSiteDetail(realmId: string, siteId: string, payload: Detail, options?: any) {
        return SiteDetailsApiFp(this.configuration).createSiteDetail(realmId, siteId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Creates new site detail location
     * @summary Create site detail location
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {DetailLocation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public createSiteDetailLocation(realmId: string, siteId: string, detailId: string, body: DetailLocation, options?: any) {
        return SiteDetailsApiFp(this.configuration).createSiteDetailLocation(realmId, siteId, detailId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates new site detail location image
     * @summary Create site detail location image
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {Image} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public createSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, body: Image, options?: any) {
        return SiteDetailsApiFp(this.configuration).createSiteDetailLocationImage(realmId, siteId, detailId, locationId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates new site detail location note
     * @summary Create site detail location note
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {DetailLocationNote} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public createSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocationNote, options?: any) {
        return SiteDetailsApiFp(this.configuration).createSiteDetailLocationNote(realmId, siteId, detailId, locationId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates new site detail shemantic
     * @summary Create site detail shemantic
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {string} detailId 
     * @param {DetailSchematic} detailSchematic Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public createSiteDetailSchematic(realmId: string, siteId: string, detailId: string, detailSchematic: DetailSchematic, options?: any) {
        return SiteDetailsApiFp(this.configuration).createSiteDetailSchematic(realmId, siteId, detailId, detailSchematic, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a detail schematic
     * @summary Delete detail schematic
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} schematicId The id of the schematic
     * @param {string} detailId The id of the detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public deleteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).deleteDetailSchematic(realmId, siteId, schematicId, detailId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a detail
     * @summary Delete detail
     * @param {string} realmId The realm id
     * @param {string} siteId The id of the site being deleted
     * @param {string} detailId The id of the detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public deleteSiteDetail(realmId: string, siteId: string, detailId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).deleteSiteDetail(realmId, siteId, detailId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site detail location
     * @summary Delete site detail location
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public deleteSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).deleteSiteDetailLocation(realmId, siteId, detailId, locationId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site detail location image
     * @summary Delete site detail location image
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {string} detailId 
     * @param {string} locationId 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public deleteSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).deleteSiteDetailLocationImage(realmId, siteId, detailId, locationId, imageId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site detail location note
     * @summary Delete site detail location note
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {string} detailId 
     * @param {string} locationId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public deleteSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).deleteSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site report
     * @summary Delete site report
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {string} reportType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public deleteSiteReport(realmId: string, siteId: string, reportType: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).deleteSiteReport(realmId, siteId, reportType, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site detail
     * @summary Finds site detail
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} detailId The id of the detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public findSiteDetail(realmId: string, siteId: string, detailId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).findSiteDetail(realmId, siteId, detailId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site detail location
     * @summary Finds site detail location
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public findSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).findSiteDetailLocation(realmId, siteId, detailId, locationId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site detail location image
     * @summary Finds site detail location image
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} imageId 
     * @param {string} locationId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public findSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, imageId: string, locationId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).findSiteDetailLocationImage(realmId, siteId, detailId, imageId, locationId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site detail location note
     * @summary Finds site detail location note
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {string} noteId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public findSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).findSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site detail schematic
     * @summary Finds site detail schematic
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} schematicId The id of the schematic
     * @param {string} detailId The id of the detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public findSiteDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).findSiteDetailSchematic(realmId, siteId, schematicId, detailId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site detail schematic data
     * @summary Finds site detail schematic data
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} schematicId The id of the schematic
     * @param {string} detailId The id of the detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public findSiteDetailSchematicData(realmId: string, siteId: string, schematicId: string, detailId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).findSiteDetailSchematicData(realmId, siteId, schematicId, detailId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds all site detail location notes
     * @summary Finds site detail location notes
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public getSiteDetailLocationNotes(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).getSiteDetailLocationNotes(realmId, siteId, detailId, locationId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds all site detail location images
     * @summary Finds site detail location images
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public listSiteDetailLocationImages(realmId: string, siteId: string, detailId: string, locationId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).listSiteDetailLocationImages(realmId, siteId, detailId, locationId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds all site detail locations
     * @summary Finds site detail locations
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} [siteSchematicId] Filter results by site schematic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public listSiteDetailLocations(realmId: string, siteId: string, detailId: string, siteSchematicId?: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).listSiteDetailLocations(realmId, siteId, detailId, siteSchematicId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds all sites detail schematics
     * @summary Finds sites detail schematics
     * @param {string} realmId The id of realm
     * @param {string} siteId The id of site
     * @param {string} detailId The id of detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public listSiteDetailSchematics(realmId: string, siteId: string, detailId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).listSiteDetailSchematics(realmId, siteId, detailId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds all sites details
     * @summary Finds sites details
     * @param {string} realmId The id of realm
     * @param {string} siteId The id of site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public listSiteDetails(realmId: string, siteId: string, options?: any) {
        return SiteDetailsApiFp(this.configuration).listSiteDetails(realmId, siteId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a detail schematic
     * @summary Update detail schematic
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} schematicId The id of the schematic
     * @param {string} detailId The id of the detail
     * @param {DetailSchematic} detailSchematic Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public updateDetailSchematic(realmId: string, siteId: string, schematicId: string, detailId: string, detailSchematic: DetailSchematic, options?: any) {
        return SiteDetailsApiFp(this.configuration).updateDetailSchematic(realmId, siteId, schematicId, detailId, detailSchematic, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a detail
     * @summary Update detail
     * @param {string} realmId The realm to be updated
     * @param {string} siteId 
     * @param {string} detailId The id of the detail
     * @param {Detail} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public updateSiteDetail(realmId: string, siteId: string, detailId: string, payload: Detail, options?: any) {
        return SiteDetailsApiFp(this.configuration).updateSiteDetail(realmId, siteId, detailId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a site detail location
     * @summary Update site detail location
     * @param {string} realmId The realm to be created
     * @param {string} siteId The realm to be created
     * @param {string} detailId The realm to be created
     * @param {string} locationId The realm to be created
     * @param {DetailLocation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public updateSiteDetailLocation(realmId: string, siteId: string, detailId: string, locationId: string, body: DetailLocation, options?: any) {
        return SiteDetailsApiFp(this.configuration).updateSiteDetailLocation(realmId, siteId, detailId, locationId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a site detail location image
     * @summary Update site detail location image
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {string} detailId 
     * @param {string} locationId 
     * @param {string} imageId 
     * @param {Image} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public updateSiteDetailLocationImage(realmId: string, siteId: string, detailId: string, locationId: string, imageId: string, body: Image, options?: any) {
        return SiteDetailsApiFp(this.configuration).updateSiteDetailLocationImage(realmId, siteId, detailId, locationId, imageId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a site detail location note
     * @summary Update site detail location note
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {string} detailId 
     * @param {string} locationId 
     * @param {string} noteId 
     * @param {DetailLocationNote} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDetailsApi
     */
    public updateSiteDetailLocationNote(realmId: string, siteId: string, detailId: string, locationId: string, noteId: string, body: DetailLocationNote, options?: any) {
        return SiteDetailsApiFp(this.configuration).updateSiteDetailLocationNote(realmId, siteId, detailId, locationId, noteId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * SiteSchematicTilesApi - fetch parameter creator
 * @export
 */
export const SiteSchematicTilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns site schematic tile image as png
         * @summary Returns site schematic tile image
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {number} z Tile zoom level
         * @param {number} x Tile x
         * @param {number} y Tile y
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteSchematicTileImage(realmId: string, siteId: string, schematicId: string, z: number, x: number, y: number, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling getSiteSchematicTileImage.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling getSiteSchematicTileImage.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling getSiteSchematicTileImage.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling getSiteSchematicTileImage.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling getSiteSchematicTileImage.');
            }
            // verify required parameter 'y' is not null or undefined
            if (y === null || y === undefined) {
                throw new RequiredError('y','Required parameter y was null or undefined when calling getSiteSchematicTileImage.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/schematics/{schematicId}/tiles/{z}/{x}/{y}.png`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteSchematicTilesApi - functional programming interface
 * @export
 */
export const SiteSchematicTilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns site schematic tile image as png
         * @summary Returns site schematic tile image
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {number} z Tile zoom level
         * @param {number} x Tile x
         * @param {number} y Tile y
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteSchematicTileImage(realmId: string, siteId: string, schematicId: string, z: number, x: number, y: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SiteSchematicTilesApiFetchParamCreator(configuration).getSiteSchematicTileImage(realmId, siteId, schematicId, z, x, y, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SiteSchematicTilesApi - factory interface
 * @export
 */
export const SiteSchematicTilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns site schematic tile image as png
         * @summary Returns site schematic tile image
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {number} z Tile zoom level
         * @param {number} x Tile x
         * @param {number} y Tile y
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteSchematicTileImage(realmId: string, siteId: string, schematicId: string, z: number, x: number, y: number, options?: any) {
            return SiteSchematicTilesApiFp(configuration).getSiteSchematicTileImage(realmId, siteId, schematicId, z, x, y, options)(fetch, basePath);
        },
    };
};

/**
 * SiteSchematicTilesApi - object-oriented interface
 * @export
 * @class SiteSchematicTilesApi
 * @extends {BaseAPI}
 */
export class SiteSchematicTilesApi extends BaseAPI {
    /**
     * Returns site schematic tile image as png
     * @summary Returns site schematic tile image
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} schematicId The id of the schematic
     * @param {number} z Tile zoom level
     * @param {number} x Tile x
     * @param {number} y Tile y
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSchematicTilesApi
     */
    public getSiteSchematicTileImage(realmId: string, siteId: string, schematicId: string, z: number, x: number, y: number, options?: any) {
        return SiteSchematicTilesApiFp(this.configuration).getSiteSchematicTileImage(realmId, siteId, schematicId, z, x, y, options)(this.fetch, this.basePath);
    }

}

/**
 * SiteSchematicsApi - fetch parameter creator
 * @export
 */
export const SiteSchematicsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new site schematic
         * @summary Create site schematic
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {SiteSchematic} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteSchematic(realmId: string, siteId: string, payload: SiteSchematic, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteSchematic.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createSiteSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/schematics`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SiteSchematic" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site schematic
         * @summary Delete site schematic
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {string} schematicId The id of the schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteSchematic(realmId: string, siteId: string, schematicId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteSchematic.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling deleteSiteSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/schematics/{schematicId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site schematic
         * @summary Finds site schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteSchematic(realmId: string, siteId: string, schematicId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteSchematic.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling findSiteSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/schematics/{schematicId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists site schematics
         * @summary Lists site schematics
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteSchematics(realmId: string, siteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSiteSchematics.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling listSiteSchematics.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/schematics`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Schematic
         * @summary Update Schematic
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} schematicId The id of the schematic
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchematic(realmId: string, siteId: string, schematicId: string, payload: Site, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSchematic.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSchematic.');
            }
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling updateSchematic.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateSchematic.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/schematics/{schematicId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"schematicId"}}`, encodeURIComponent(String(schematicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Site" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteSchematicsApi - functional programming interface
 * @export
 */
export const SiteSchematicsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new site schematic
         * @summary Create site schematic
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {SiteSchematic} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteSchematic(realmId: string, siteId: string, payload: SiteSchematic, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteSchematic> {
            const localVarFetchArgs = SiteSchematicsApiFetchParamCreator(configuration).createSiteSchematic(realmId, siteId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site schematic
         * @summary Delete site schematic
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {string} schematicId The id of the schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteSchematic(realmId: string, siteId: string, schematicId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteSchematicsApiFetchParamCreator(configuration).deleteSiteSchematic(realmId, siteId, schematicId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site schematic
         * @summary Finds site schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteSchematic(realmId: string, siteId: string, schematicId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteSchematic> {
            const localVarFetchArgs = SiteSchematicsApiFetchParamCreator(configuration).findSiteSchematic(realmId, siteId, schematicId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists site schematics
         * @summary Lists site schematics
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteSchematics(realmId: string, siteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SiteSchematic>> {
            const localVarFetchArgs = SiteSchematicsApiFetchParamCreator(configuration).listSiteSchematics(realmId, siteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Schematic
         * @summary Update Schematic
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} schematicId The id of the schematic
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchematic(realmId: string, siteId: string, schematicId: string, payload: Site, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Site> {
            const localVarFetchArgs = SiteSchematicsApiFetchParamCreator(configuration).updateSchematic(realmId, siteId, schematicId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SiteSchematicsApi - factory interface
 * @export
 */
export const SiteSchematicsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new site schematic
         * @summary Create site schematic
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {SiteSchematic} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteSchematic(realmId: string, siteId: string, payload: SiteSchematic, options?: any) {
            return SiteSchematicsApiFp(configuration).createSiteSchematic(realmId, siteId, payload, options)(fetch, basePath);
        },
        /**
         * Deletes a site schematic
         * @summary Delete site schematic
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {string} schematicId The id of the schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteSchematic(realmId: string, siteId: string, schematicId: string, options?: any) {
            return SiteSchematicsApiFp(configuration).deleteSiteSchematic(realmId, siteId, schematicId, options)(fetch, basePath);
        },
        /**
         * Finds a site schematic
         * @summary Finds site schematic
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} schematicId The id of the schematic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteSchematic(realmId: string, siteId: string, schematicId: string, options?: any) {
            return SiteSchematicsApiFp(configuration).findSiteSchematic(realmId, siteId, schematicId, options)(fetch, basePath);
        },
        /**
         * Lists site schematics
         * @summary Lists site schematics
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteSchematics(realmId: string, siteId: string, options?: any) {
            return SiteSchematicsApiFp(configuration).listSiteSchematics(realmId, siteId, options)(fetch, basePath);
        },
        /**
         * Updates a Schematic
         * @summary Update Schematic
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} schematicId The id of the schematic
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchematic(realmId: string, siteId: string, schematicId: string, payload: Site, options?: any) {
            return SiteSchematicsApiFp(configuration).updateSchematic(realmId, siteId, schematicId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * SiteSchematicsApi - object-oriented interface
 * @export
 * @class SiteSchematicsApi
 * @extends {BaseAPI}
 */
export class SiteSchematicsApi extends BaseAPI {
    /**
     * Creates new site schematic
     * @summary Create site schematic
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {SiteSchematic} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSchematicsApi
     */
    public createSiteSchematic(realmId: string, siteId: string, payload: SiteSchematic, options?: any) {
        return SiteSchematicsApiFp(this.configuration).createSiteSchematic(realmId, siteId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site schematic
     * @summary Delete site schematic
     * @param {string} realmId The realm id
     * @param {string} siteId The id of the site being deleted
     * @param {string} schematicId The id of the schematic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSchematicsApi
     */
    public deleteSiteSchematic(realmId: string, siteId: string, schematicId: string, options?: any) {
        return SiteSchematicsApiFp(this.configuration).deleteSiteSchematic(realmId, siteId, schematicId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site schematic
     * @summary Finds site schematic
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} schematicId The id of the schematic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSchematicsApi
     */
    public findSiteSchematic(realmId: string, siteId: string, schematicId: string, options?: any) {
        return SiteSchematicsApiFp(this.configuration).findSiteSchematic(realmId, siteId, schematicId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists site schematics
     * @summary Lists site schematics
     * @param {string} realmId The id of realm
     * @param {string} siteId The id of site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSchematicsApi
     */
    public listSiteSchematics(realmId: string, siteId: string, options?: any) {
        return SiteSchematicsApiFp(this.configuration).listSiteSchematics(realmId, siteId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Schematic
     * @summary Update Schematic
     * @param {string} realmId The realm to be updated
     * @param {string} siteId 
     * @param {string} schematicId The id of the schematic
     * @param {Site} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSchematicsApi
     */
    public updateSchematic(realmId: string, siteId: string, schematicId: string, payload: Site, options?: any) {
        return SiteSchematicsApiFp(this.configuration).updateSchematic(realmId, siteId, schematicId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * SiteUsersApi - fetch parameter creator
 * @export
 */
export const SiteUsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new site user
         * @summary Create site user
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {SiteUser} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteUser(realmId: string, siteId: string, payload: SiteUser, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSiteUser.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling createSiteUser.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createSiteUser.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/users`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SiteUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site user
         * @summary Delete site user
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteUser(realmId: string, siteId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSiteUser.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteSiteUser.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/users/{userId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site user
         * @summary Finds site user
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteUser(realmId: string, siteId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSiteUser.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSiteUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling findSiteUser.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/users/{userId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all site users
         * @summary Lists site users
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteUsers(realmId: string, siteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSiteUsers.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling listSiteUsers.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/users`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a site user
         * @summary Update site user
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} userId The id of the user
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteUser(realmId: string, siteId: string, userId: string, payload: Site, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSiteUser.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSiteUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateSiteUser.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateSiteUser.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}/users/{userId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Site" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteUsersApi - functional programming interface
 * @export
 */
export const SiteUsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new site user
         * @summary Create site user
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {SiteUser} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteUser(realmId: string, siteId: string, payload: SiteUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteUser> {
            const localVarFetchArgs = SiteUsersApiFetchParamCreator(configuration).createSiteUser(realmId, siteId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site user
         * @summary Delete site user
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteUser(realmId: string, siteId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SiteUsersApiFetchParamCreator(configuration).deleteSiteUser(realmId, siteId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site user
         * @summary Finds site user
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteUser(realmId: string, siteId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteUser> {
            const localVarFetchArgs = SiteUsersApiFetchParamCreator(configuration).findSiteUser(realmId, siteId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all site users
         * @summary Lists site users
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteUsers(realmId: string, siteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SiteUser>> {
            const localVarFetchArgs = SiteUsersApiFetchParamCreator(configuration).listSiteUsers(realmId, siteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a site user
         * @summary Update site user
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} userId The id of the user
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteUser(realmId: string, siteId: string, userId: string, payload: Site, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Site> {
            const localVarFetchArgs = SiteUsersApiFetchParamCreator(configuration).updateSiteUser(realmId, siteId, userId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SiteUsersApi - factory interface
 * @export
 */
export const SiteUsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new site user
         * @summary Create site user
         * @param {string} realmId 
         * @param {string} siteId 
         * @param {SiteUser} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteUser(realmId: string, siteId: string, payload: SiteUser, options?: any) {
            return SiteUsersApiFp(configuration).createSiteUser(realmId, siteId, payload, options)(fetch, basePath);
        },
        /**
         * Deletes a site user
         * @summary Delete site user
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteUser(realmId: string, siteId: string, userId: string, options?: any) {
            return SiteUsersApiFp(configuration).deleteSiteUser(realmId, siteId, userId, options)(fetch, basePath);
        },
        /**
         * Finds a site user
         * @summary Finds site user
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSiteUser(realmId: string, siteId: string, userId: string, options?: any) {
            return SiteUsersApiFp(configuration).findSiteUser(realmId, siteId, userId, options)(fetch, basePath);
        },
        /**
         * Lists all site users
         * @summary Lists site users
         * @param {string} realmId The id of realm
         * @param {string} siteId The id of site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiteUsers(realmId: string, siteId: string, options?: any) {
            return SiteUsersApiFp(configuration).listSiteUsers(realmId, siteId, options)(fetch, basePath);
        },
        /**
         * Updates a site user
         * @summary Update site user
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {string} userId The id of the user
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteUser(realmId: string, siteId: string, userId: string, payload: Site, options?: any) {
            return SiteUsersApiFp(configuration).updateSiteUser(realmId, siteId, userId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * SiteUsersApi - object-oriented interface
 * @export
 * @class SiteUsersApi
 * @extends {BaseAPI}
 */
export class SiteUsersApi extends BaseAPI {
    /**
     * Creates new site user
     * @summary Create site user
     * @param {string} realmId 
     * @param {string} siteId 
     * @param {SiteUser} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteUsersApi
     */
    public createSiteUser(realmId: string, siteId: string, payload: SiteUser, options?: any) {
        return SiteUsersApiFp(this.configuration).createSiteUser(realmId, siteId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site user
     * @summary Delete site user
     * @param {string} realmId The realm id
     * @param {string} siteId The id of the site
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteUsersApi
     */
    public deleteSiteUser(realmId: string, siteId: string, userId: string, options?: any) {
        return SiteUsersApiFp(this.configuration).deleteSiteUser(realmId, siteId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site user
     * @summary Finds site user
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteUsersApi
     */
    public findSiteUser(realmId: string, siteId: string, userId: string, options?: any) {
        return SiteUsersApiFp(this.configuration).findSiteUser(realmId, siteId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all site users
     * @summary Lists site users
     * @param {string} realmId The id of realm
     * @param {string} siteId The id of site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteUsersApi
     */
    public listSiteUsers(realmId: string, siteId: string, options?: any) {
        return SiteUsersApiFp(this.configuration).listSiteUsers(realmId, siteId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a site user
     * @summary Update site user
     * @param {string} realmId The realm to be updated
     * @param {string} siteId 
     * @param {string} userId The id of the user
     * @param {Site} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteUsersApi
     */
    public updateSiteUser(realmId: string, siteId: string, userId: string, payload: Site, options?: any) {
        return SiteUsersApiFp(this.configuration).updateSiteUser(realmId, siteId, userId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * SitesApi - fetch parameter creator
 * @export
 */
export const SitesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new site
         * @summary Create site
         * @param {string} realmId 
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSite(realmId: string, payload: Site, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createSite.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createSite.');
            }
            const localVarPath = `/realms/{realmId}/sites`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Site" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a site
         * @summary Delete site
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite(realmId: string, siteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteSite.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSite.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a site
         * @summary Finds site
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSite(realmId: string, siteId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findSite.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling findSite.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of realm sites
         * @summary Lists sites
         * @param {string} realmId The relam id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites(realmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listSites.');
            }
            const localVarPath = `/realms/{realmId}/sites`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a site
         * @summary Update site
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite(realmId: string, siteId: string, payload: Site, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateSite.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSite.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateSite.');
            }
            const localVarPath = `/realms/{realmId}/sites/{siteId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Site" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitesApi - functional programming interface
 * @export
 */
export const SitesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new site
         * @summary Create site
         * @param {string} realmId 
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSite(realmId: string, payload: Site, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Site> {
            const localVarFetchArgs = SitesApiFetchParamCreator(configuration).createSite(realmId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a site
         * @summary Delete site
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite(realmId: string, siteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SitesApiFetchParamCreator(configuration).deleteSite(realmId, siteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds a site
         * @summary Finds site
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSite(realmId: string, siteId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Site> {
            const localVarFetchArgs = SitesApiFetchParamCreator(configuration).findSite(realmId, siteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of realm sites
         * @summary Lists sites
         * @param {string} realmId The relam id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites(realmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Site>> {
            const localVarFetchArgs = SitesApiFetchParamCreator(configuration).listSites(realmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a site
         * @summary Update site
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite(realmId: string, siteId: string, payload: Site, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Site> {
            const localVarFetchArgs = SitesApiFetchParamCreator(configuration).updateSite(realmId, siteId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SitesApi - factory interface
 * @export
 */
export const SitesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new site
         * @summary Create site
         * @param {string} realmId 
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSite(realmId: string, payload: Site, options?: any) {
            return SitesApiFp(configuration).createSite(realmId, payload, options)(fetch, basePath);
        },
        /**
         * Deletes a site
         * @summary Delete site
         * @param {string} realmId The realm id
         * @param {string} siteId The id of the site being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite(realmId: string, siteId: string, options?: any) {
            return SitesApiFp(configuration).deleteSite(realmId, siteId, options)(fetch, basePath);
        },
        /**
         * Finds a site
         * @summary Finds site
         * @param {string} realmId The id of the realm
         * @param {string} siteId The id of the site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSite(realmId: string, siteId: string, options?: any) {
            return SitesApiFp(configuration).findSite(realmId, siteId, options)(fetch, basePath);
        },
        /**
         * List of realm sites
         * @summary Lists sites
         * @param {string} realmId The relam id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites(realmId: string, options?: any) {
            return SitesApiFp(configuration).listSites(realmId, options)(fetch, basePath);
        },
        /**
         * Updates a site
         * @summary Update site
         * @param {string} realmId The realm to be updated
         * @param {string} siteId 
         * @param {Site} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite(realmId: string, siteId: string, payload: Site, options?: any) {
            return SitesApiFp(configuration).updateSite(realmId, siteId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * SitesApi - object-oriented interface
 * @export
 * @class SitesApi
 * @extends {BaseAPI}
 */
export class SitesApi extends BaseAPI {
    /**
     * Creates new site
     * @summary Create site
     * @param {string} realmId 
     * @param {Site} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public createSite(realmId: string, payload: Site, options?: any) {
        return SitesApiFp(this.configuration).createSite(realmId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a site
     * @summary Delete site
     * @param {string} realmId The realm id
     * @param {string} siteId The id of the site being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public deleteSite(realmId: string, siteId: string, options?: any) {
        return SitesApiFp(this.configuration).deleteSite(realmId, siteId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds a site
     * @summary Finds site
     * @param {string} realmId The id of the realm
     * @param {string} siteId The id of the site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public findSite(realmId: string, siteId: string, options?: any) {
        return SitesApiFp(this.configuration).findSite(realmId, siteId, options)(this.fetch, this.basePath);
    }

    /**
     * List of realm sites
     * @summary Lists sites
     * @param {string} realmId The relam id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public listSites(realmId: string, options?: any) {
        return SitesApiFp(this.configuration).listSites(realmId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a site
     * @summary Update site
     * @param {string} realmId The realm to be updated
     * @param {string} siteId 
     * @param {Site} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public updateSite(realmId: string, siteId: string, payload: Site, options?: any) {
        return SitesApiFp(this.configuration).updateSite(realmId, siteId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new user
         * @summary Create user
         * @param {string} realmId The realm to be updated
         * @param {string} password Initial password for the user
         * @param {User} body The user to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(realmId: string, password: string, body: User, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling createUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createUser.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/realms/{realmId}/users`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an user
         * @summary Delete user
         * @param {string} realmId The id of the realm being deleted
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(realmId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/realms/{realmId}/users/{userId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds an user
         * @summary Finds user
         * @param {string} realmId The id of the realm
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUser(realmId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling findUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling findUser.');
            }
            const localVarPath = `/realms/{realmId}/users/{userId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists realm users
         * @summary List users
         * @param {string} realmId The realm to be updated
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(realmId: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling listUsers.');
            }
            const localVarPath = `/realms/{realmId}/users`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an user
         * @summary Update user
         * @param {string} realmId The realm to be updated
         * @param {string} userId The id of the user
         * @param {User} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(realmId: string, userId: string, payload: User, options: any = {}): FetchArgs {
            // verify required parameter 'realmId' is not null or undefined
            if (realmId === null || realmId === undefined) {
                throw new RequiredError('realmId','Required parameter realmId was null or undefined when calling updateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateUser.');
            }
            const localVarPath = `/realms/{realmId}/users/{userId}`
                .replace(`{${"realmId"}}`, encodeURIComponent(String(realmId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new user
         * @summary Create user
         * @param {string} realmId The realm to be updated
         * @param {string} password Initial password for the user
         * @param {User} body The user to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(realmId: string, password: string, body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(realmId, password, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an user
         * @summary Delete user
         * @param {string} realmId The id of the realm being deleted
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(realmId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(realmId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds an user
         * @summary Finds user
         * @param {string} realmId The id of the realm
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUser(realmId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findUser(realmId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists realm users
         * @summary List users
         * @param {string} realmId The realm to be updated
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(realmId: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(realmId, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an user
         * @summary Update user
         * @param {string} realmId The realm to be updated
         * @param {string} userId The id of the user
         * @param {User} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(realmId: string, userId: string, payload: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(realmId, userId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new user
         * @summary Create user
         * @param {string} realmId The realm to be updated
         * @param {string} password Initial password for the user
         * @param {User} body The user to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(realmId: string, password: string, body: User, options?: any) {
            return UsersApiFp(configuration).createUser(realmId, password, body, options)(fetch, basePath);
        },
        /**
         * Deletes an user
         * @summary Delete user
         * @param {string} realmId The id of the realm being deleted
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(realmId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(realmId, userId, options)(fetch, basePath);
        },
        /**
         * Finds an user
         * @summary Finds user
         * @param {string} realmId The id of the realm
         * @param {string} userId The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUser(realmId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).findUser(realmId, userId, options)(fetch, basePath);
        },
        /**
         * Lists realm users
         * @summary List users
         * @param {string} realmId The realm to be updated
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(realmId: string, firstResult?: number, maxResults?: number, options?: any) {
            return UsersApiFp(configuration).listUsers(realmId, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Updates an user
         * @summary Update user
         * @param {string} realmId The realm to be updated
         * @param {string} userId The id of the user
         * @param {User} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(realmId: string, userId: string, payload: User, options?: any) {
            return UsersApiFp(configuration).updateUser(realmId, userId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Creates new user
     * @summary Create user
     * @param {string} realmId The realm to be updated
     * @param {string} password Initial password for the user
     * @param {User} body The user to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(realmId: string, password: string, body: User, options?: any) {
        return UsersApiFp(this.configuration).createUser(realmId, password, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an user
     * @summary Delete user
     * @param {string} realmId The id of the realm being deleted
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(realmId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(realmId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Finds an user
     * @summary Finds user
     * @param {string} realmId The id of the realm
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUser(realmId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).findUser(realmId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists realm users
     * @summary List users
     * @param {string} realmId The realm to be updated
     * @param {number} [firstResult] First result
     * @param {number} [maxResults] Max results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(realmId: string, firstResult?: number, maxResults?: number, options?: any) {
        return UsersApiFp(this.configuration).listUsers(realmId, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an user
     * @summary Update user
     * @param {string} realmId The realm to be updated
     * @param {string} userId The id of the user
     * @param {User} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(realmId: string, userId: string, payload: User, options?: any) {
        return UsersApiFp(this.configuration).updateUser(realmId, userId, payload, options)(this.fetch, this.basePath);
    }

}

